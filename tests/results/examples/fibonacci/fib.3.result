Here is a simple Python function that computes the Fibonacci sequence using recursion:

```python
def fibonacci(n):
    if n <= 0:
        return "Input should be a positive integer."
    elif n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

This function takes an integer `n` as input and returns the nth number in the Fibonacci sequence. However, it's important to note that this implementation has exponential time complexity due to repeated calculations of the same subproblems (i.e., it performs a lot of redundant work). For larger inputs, you should use an iterative approach or memoization for better performance:

```python
def fibonacci_iterative(n):
    if n <= 0:
        return "Input should be a positive integer."
    elif n == 1:
        return 0
    elif n == 2:
        return 1

    fib_values = [0, 1] + [0] * (n - 2)
    for i in range(2, n):
        fib_values[i] = fib_values[i - 1] + fib_values[i - 2]
    return fib_values[n - 1]
```

This version of the function has linear time complexity and is more efficient for larger inputs.
Find a random number between 1 and 20
15
Now computing fibonacci(15)

def fibonacci(n):
    if n <= 0:
        return "Input should be a positive integer."
    elif n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
The result is: 377

Explain what the above code does and what the result means

The provided Python function `fibonacci(n)` calculates the nth number in the Fibonacci sequence, where each number is the sum of the two preceding ones (starting from 0 and 1). Here's a breakdown of how it works:

1. **Base Cases**:
   - If `n` is less than or equal to 0, return an error message "Input should be a positive integer." This ensures that the function doesn't attempt to calculate the Fibonacci of non-positive integers.
   - If `n` is 1, return 0. The first number in the Fibonacci sequence is 0.
   - If `n` is 2, return 1. The second number in the Fibonacci sequence is 1.

2. **Recursive Case**:
   - For any other positive integer `n`, the function calls itself twice with arguments `n-1` and `n-2`. It then returns the sum of these two recursive calls: `fibonacci(n - 1) + fibonacci(n - 2)`. This is based on the definition of the Fibonacci sequence, where each number is the sum of the previous two.

Given that you asked for a random number between 1 and 20, let's use this function to find `fibonacci(15)` as an example:

- `n = 15`
- According to our function definition:
  - `fibonacci(14) + fibonacci(13)` (since `n == 15`)
  - `fibonacci(13) + fibonacci(12)` (since `n == 14`)
  - And so on, until we reach the base cases.
- The function will calculate:
  - `fibonacci(13) + fibonacci(12)`
  - `fibonacci(12) + fibonacci(11)`
  - ...
  - `fibonacci(2) + fibonacci(1)`
  - Finally, `fibonacci(1) + fibonacci(0)`
- The result of these calculations is 377.

So, the output `377` indicates that when you asked for a random number between 1 and 20, the function calculated the 15th number in the Fibonacci sequence (which is 377). This demonstrates how the recursive implementation of the Fibonacci sequence can produce large numbers quickly due to its exponential time complexity.