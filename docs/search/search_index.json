{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#prompt-description-language","title":"Prompt Description Language","text":"<p>LLMs will continue to change the way we build software systems. They are not only useful as coding assistants, providing snipets of code, explanations, and code transformations, but they can also help replace components that could only previously be achieved with rule-based systems. Whether LLMs are used as coding assistants or software components, reliability remains an important concern. LLMs have a textual interface and the structure of useful prompts is not captured formally. Programming frameworks do not enforce or validate such structures since they are not specified in a machine-consumable way. The purpose of the Prompt Description Language (PDL) is to allow developers to specify the structure of prompts and to enforce it, while providing a unified programming framework for composing LLMs with rule-based systems. </p> <p>PDL is based on the premise that interactions between users, LLMs and rule-based systems form a document. Consider for example the interactions between a user and a chatbot. At each interaction, the exchanges form a document that gets longer and longer. Similarly, chaining models together or using tools for specific tasks result in outputs that together form a document. PDL allows users to specify the shape and contents of such documents in a declarative way (in YAML or JSON), and is agnostic of any programming language. Because of its document-oriented nature, it can be used to easily express a variety of data generation tasks (inference, data synthesis, data generation for model training, etc...). Moreover, PDL programs themselves are structured data (YAML) as opposed to traditional code, so they make good targets for LLM generation as well.</p> <p>PDL provides the following features: - Ability to templatize not only prompts for one LLM call, but also composition of LLMs with tools (code and APIs). Templates can encompass tasks of larger granularity than a single LLM call (unlike many prompt programming languages). - Control structures: variable definitions and use, conditionals, loops, functions - Ability to read from files, including JSON data. - Ability to call out to code. At the moment only Python is supported, but this could be any other programming language in principle. - Ability to call out to REST APIS.</p> <p>The PDL interpreter (<code>pdl/pdl.py</code>) takes a PDL program as input and renders it into a document by execution its instructions (calling out to models, code, apis, etc...). </p> <p>See below for installation notes, followed by an overview of the language. A more detailed description of the language features can be found in this tutorial.</p>"},{"location":"#interpreter-installation","title":"Interpreter Installation","text":"<p>The interpreter has been tested with Python version 3.12.</p> <p>To install the requirements for <code>pdl</code>, execute the command:</p> <pre><code>pip3 install .\n</code></pre> <p>To install the dependencies for development of PDL and execute all the example, execute the command: <pre><code>pip3 install '.[all]'\n</code></pre></p> <p>In order to run the examples that use foundation models hosted on watsonx, you need an account (a free plan is available) and set up the following environment variables: - <code>WATSONX_API</code>, the API url (set to <code>https://{region}.ml.cloud.ibm.com</code>) - <code>WATSONX_KEY</code>, the API key (see information on key creation) - <code>WATSONX_PROJECT_ID</code>, the project hosting the resources (see information about project creation and finding project ID).</p> <p>Internal IBM users can use models hosted on BAM. You need to set up 2 environment variables: - <code>GENAI_API</code> set to <code>https://bam-api.res.ibm.com/</code> - <code>GENAI_KEY</code> set to your BAM API key. To obtain your key, go to the BAM main page. On the right and under the \"Documentation\" section, you will see a button to copy your API key.</p> <p>To run the interpreter:</p> <pre><code>python3 -m pdl.pdl &lt;path/to/example.yaml&gt;\n</code></pre> <p>The folder <code>examples</code> contains some examples of PDL programs. Several of these examples have been adapted from the LMQL paper by Beurer-Kellner et al. </p> <p>We highly recommend to use VSCode to edit PDL YAML files. This project has been configured so that every YAML file is associated with the PDL grammar JSONSchema (see settings and schema). This enables the editor to display error messages when the yaml deviates from the PDL syntax and grammar. It also provides code completion. You can set up your own VSCode PDL projects similarly using this settings and schema files. The PDL interpreter also provides similar error messages.</p> <p>The interpreter prints out a log by default in the file <code>log.txt</code>. This log contains the details of inputs and outputs to every block in the program. It is useful to examine this file when the program is behaving differently than expected.</p> <p>To change the log filename, you can pass it to the interpreter as follows:</p> <pre><code>python3 -m pdl.pdl --log &lt;my-logfile&gt; &lt;my-example&gt;\n</code></pre> <p>We can also pass initial data to the interpreter to populate variables used in a PDL program, as follows:</p> <pre><code>python3 -m pdl.pdl --data &lt;JSON-or-YAML-data&gt; &lt;my-example&gt;\n</code></pre> <p>This can also be done by passing a JSON or YAML file:</p> <pre><code>python3 -m pdl.pdl --data_file &lt;JSON-or-YAML-file&gt; &lt;my-example&gt;\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<p>In PDL, we can write some YAML to create a prompt and call an LLM:</p> <pre><code>description: Hello world with watsonx\ndocument:\n- Hello\n- model: ibm/granite-3b-code-instruct\n  params:\n    STOP_SEQUENCES:\n    - '!'\n</code></pre> <p>The <code>description</code> field is a description for the program. Field <code>document</code> contains a list of either strings or blocks which together form the document to be produced. In this example, the document starts with the string <code>\"Hello\"</code> followed by a block that calls out to a model. In this case, it is model with id <code>ibm/granite-3b-code-instruct</code> from watsonx, with the indicated parameter: the stop sequence is <code>!</code>. The input to the model call is everything that has been produced so far in the document (here <code>Hello</code>).</p> <p>When we execute this program using the PDL interpreter:</p> <pre><code>python3 -m pdl.pdl examples/hello/hello.yaml\n</code></pre> <p>we obtain the following document:</p> <pre><code>Hello, world!\n</code></pre> <p>where the portion <code>, world!</code> was produced by granite. In general, PDL provides blocks for calling to models, Python code, as well as APIs and makes it easy to compose them together with control structures (sequencing, conditions, loops).</p> <p>The equivalent program using a model hosted on BAM can be written as follows:</p> <pre><code>description: Hello world with BAM\ndocument:\n- Hello\n- model: ibm/granite-3b-code-instruct\n  parameters:\n    decoding_method: greedy\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true\n</code></pre> <p>The only difference is that the parameters of the model now follows the BAM calling convention. The <code>decoding_method</code> is <code>greedy</code> and there is a stop sequence <code>!</code> which must be included in the output.</p> <p>Consider now an example from AI for code, where we want to build a prompt template for code explanation. We have a JSON file as input containing the source code and some information regarding the repository where it came from.</p> <p>For example, given the data in this JSON file: <pre><code>{\n    \"source_code\": \"@SuppressWarnings(\\\"unchecked\\\")\\npublic static Map&lt;String, String&gt; deserializeOffsetMap(String lastSourceOffset) throws IOException {\\n  Map&lt;String, String&gt; offsetMap;\\n  if (lastSourceOffset == null || lastSourceOffset.isEmpty()) {\\n    offsetMap = new HashMap&lt;&gt;();\\n  } else {\\n    offsetMap = JSON_MAPPER.readValue(lastSourceOffset, Map.class);\\n  }\\n  return offsetMap;\\n}\",\n    \"repo_info\": {\n        \"repo\": \"streamsets/datacollector\",\n        \"path\": \"stagesupport/src/main/java/com/.../OffsetUtil.java\",\n        \"function_name\": \"OffsetUtil.deserializeOffsetMap\"\n    }\n}\n</code></pre></p> <p>we would like to express the following prompt and submit it to an LLM:</p> <pre><code>Here is some info about the location of the function in the repo.\nrepo: \nstreamsets/datacollector\npath: stagesupport/src/main/java/com/.../OffsetUtil.java\nFunction_name: OffsetUtil.deserializeOffsetMap\n\n\nExplain the following code:\n\n@SuppressWarnings(\"unchecked\")\npublic static Map&lt;String, String&gt; deserializeOffsetMap(String lastSourceOffset) throws IOException {\n  Map&lt;String, String&gt; offsetMap;\n  if (lastSourceOffset == null || lastSourceOffset.isEmpty()) {\n    offsetMap = new HashMap&lt;&gt;();\n  } else {\n    offsetMap = JSON_MAPPER.readValue(lastSourceOffset, Map.class);\n  }\n  return offsetMap;\n}\n</code></pre> <p>In PDL, this would be expressed as follows (see file):</p> <pre><code>description: Code explanation example\ndocument:\n- read: examples/code/data.json\n  parser: json\n  def: CODE\n  show_result: False\n- \"\\n{{ CODE.source_code }}\\n\"\n- model: ibm/granite-20b-code-instruct-v2\n  input:\n     |\n      Here is some info about the location of the function in the repo.\n      repo: \n      {{ CODE.repo_info.repo }}\n      path: {{ CODE.repo_info.path }}\n      Function_name: {{ CODE.repo_info.function_name }}\n\n\n      Explain the following code:\n      ```\n      {{ CODE.source_code }}```\n</code></pre> <p>The first block of the document is an input block. It reads the indicated filename (<code>examples/code/data.json</code>) and loads its contents into a variable named <code>CODE</code>. In PDL, any block can have a <code>def</code> field, which means the output of that block is assigned to that variable. Since the field <code>parser</code> is set to <code>json</code>, variable <code>CODE</code> contains that data in JSON format. The final field in the input block says that <code>show_result</code> is set to <code>false</code>, which means that the output of this block (the content that was read) is not included in the document. This feature allows the user to obtain intermediate results that are not necessarily included in the final output.</p> <p>The second block is simply a string and writes out the source code. This is done by accessing the variable <code>CODE</code>. The syntax <code>{{ var }}</code> means accessing the value of a variable in the scope. Since <code>CODE</code> contains JSON data, we can also access fields such as <code>CODE.source_code</code>.</p> <p>The third block calls a granite model. Here we explicitly provide an <code>input</code> field which means that we do not pass the entire document produced so far to the model, but only what is specified in this field. In this case, we specify our template by using the variable <code>CODE</code> as shown above.</p> <p>When we execute this program with the PDL interpreter, we obtain the following document:</p> <pre><code>@SuppressWarnings(\"unchecked\")\npublic static Map&lt;String, String&gt; deserializeOffsetMap(String lastSourceOffset) throws IOException {\n  Map&lt;String, String&gt; offsetMap;\n  if (lastSourceOffset == null || lastSourceOffset.isEmpty()) {\n    offsetMap = new HashMap&lt;&gt;();\n  } else {\n    offsetMap = JSON_MAPPER.readValue(lastSourceOffset, Map.class);\n  }\n  return offsetMap;\n}\n\nAnswer:\nThe above code is a part of the StreamSets Data Collector that deserializes an offset map from a string. The function takes in a string representing the last source offset and returns a map containing the deserialized offsets.\n\nThe @SuppressWarnings annotation is used to suppress warnings related to unchecked operations performed by the Jackson library. This is necessary because the deserializeOffsetMap function uses generics to handle different types of maps, but the Jackson library does not support generic types.\n\nThe deserializeOffsetMap function first checks if the lastSourceOffset parameter is null or empty. If it is, then a new empty map is created and returned. Otherwise, the lastSourceOffset parameter is deserialized using the Jackson library's ObjectMapper class and returned as a map.\n</code></pre> <p>Notice that in PDL variables are used to templatize any entity in the document, not just textual prompts to LLMs. We can add a block to this document to evaluate the quality of the output using a similarity metric with respect to our ground truth. See file:</p> <pre><code>description: Code explanation example\ndocument:\n- read: examples/code/data.json\n  parser: json\n  def: CODE\n  show_result: False\n- read: examples/code/ground_truth.txt\n  def: TRUTH\n  show_result: False\n- \"\\n{{ CODE.source_code }}\\n\"\n- model: ibm/granite-20b-code-instruct-v2\n  def: EXPLANATION\n  parameters:\n    decoding_method: greedy\n    max_new_tokens: 1024\n  input:\n    document:\n    - |\n      Here is some info about the location of the function in the repo.\n      repo: \n      {{ CODE.repo_info.repo }}\n      path: {{ CODE.repo_info.path }}\n      Function_name: {{ CODE.repo_info.function_name }}\n\n\n      Explain the following code:\n      ```\n      {{ CODE.source_code }}```\n- |\n\n\n  EVALUATION:\n  The similarity (Levenshtein) between this answer and the ground truth is:\n- def: EVAL\n  lan: python\n  code:\n  - |\n    import textdistance\n    expl = \"\"\"\n    {{ EXPLANATION }}\n    \"\"\"\n    truth = \"\"\"\n    {{ TRUTH }}\n    \"\"\"\n    result = textdistance.levenshtein.normalized_similarity(expl, truth)\n</code></pre> <p>This program has an input block that reads the ground truth from filename <code>examples/code/ground_truth.txt</code> and assigns its contents to variable <code>TRUTH</code>. It also assigns the output of the model to the variable <code>EXPLANATION</code>. The last block is a call to Python code, which is included after the <code>code</code> field. Notice how code is included here simply as data. We collate fragments of Python with outputs obtained from previous blocks. This is one of the powerful features of PDL: the ability to specify the execution of code that is not known ahead of time. We can use LLMs to generate code that is later executed in the same programming model. This is made possible because PDL treats code as data, like any another part of the document.</p> <p>When we execute this new program, we obtain the following:</p> <pre><code>@SuppressWarnings(\"unchecked\")\npublic static Map&lt;String, String&gt; deserializeOffsetMap(String lastSourceOffset) throws IOException {\n  Map&lt;String, String&gt; offsetMap;\n  if (lastSourceOffset == null || lastSourceOffset.isEmpty()) {\n    offsetMap = new HashMap&lt;&gt;();\n  } else {\n    offsetMap = JSON_MAPPER.readValue(lastSourceOffset, Map.class);\n  }\n  return offsetMap;\n}\n\nAnswer:\nThe above code is a part of the StreamSets Data Collector that deserializes an offset map from a string. The function takes in a string representing the last source offset and returns a map containing the deserialized offsets.\n\nThe @SuppressWarnings annotation is used to suppress warnings related to unchecked operations performed by the Jackson library. This is necessary because the deserializeOffsetMap function uses generics to handle different types of maps, but the Jackson library does not support generic types.\n\nThe deserializeOffsetMap function first checks if the lastSourceOffset parameter is null or empty. If it is, then a new empty map is created and returned. Otherwise, the lastSourceOffset parameter is deserialized using the Jackson library's ObjectMapper class and returned as a map.\n\nEVALUATION:\nThe similarity (Levenshtein) between this answer and the ground truth is:\n0.9987730061349693\n</code></pre> <p>PDL allows rapid prototyping of prompts by allowing the user to change prompts and see the effects on metrics. Try it!</p> <p>Finally, we can output JSON data as a result of this program, as follows:</p> <pre><code>description: Code explanation example\ndocument:\n- read: examples/code/data.json\n  parser: json\n  def: CODE\n  show_result: False\n- read: examples/code/ground_truth.txt\n  def: TRUTH\n  show_result: False\n- model: ibm/granite-20b-code-instruct-v2\n  def: EXPLANATION\n  show_result: False\n  parameters:\n    decoding_method: greedy\n    max_new_tokens: 1024\n  input:\n     |\n      Here is some info about the location of the function in the repo.\n      repo: \n      {{ CODE.repo_info.repo }}\n      path: {{ CODE.repo_info.path }}\n      Function_name: {{ CODE.repo_info.function_name }}\n\n\n      Explain the following code:\n      ```\n      {{ CODE.source_code }}```\n- def: EVAL\n  show_result: False\n  lan: python\n  code:\n    |\n    import textdistance\n    expl = \"\"\"\n    {{ EXPLANATION }}\n    \"\"\"\n    truth = \"\"\"\n    {{ TRUTH }}\n    \"\"\"\n    result = textdistance.levenshtein.normalized_similarity(expl, truth)\n- data:\n    input: \"{{ CODE }}\"\n    output: \"{{ EXPLANATION }}\"\n    metric: \"{{ EVAL }}\"\n</code></pre> <p>The data block takes various variables and combines their values into a JSON object with fields <code>input</code>, <code>output</code>, and <code>metric</code>. We mute the output of all the other blocks with <code>show_result</code> set to <code>false</code>. The output of this program is the corresponding serialized JSON object, with the appropriate treatment of quotation marks. Such PDL programs can be bootstrapped in a bash or Python script to create data en masse.</p>"},{"location":"#pdl-language-tutorial","title":"PDL Language Tutorial","text":"<p>See PDL Language Tutorial</p>"},{"location":"#additional-notes-and-future-work","title":"Additional Notes and Future Work","text":"<ul> <li>Currently, model blocks support the text generation interface of BAM, with the exception that we provide some default values when the following parameters are missing:</li> <li><code>decoding_method</code>: <code>greedy</code></li> <li><code>max_new_tokens</code>: 1024</li> <li><code>min_new_tokens</code>: 1</li> <li><code>repetition_penalty</code>: 1.05</li> </ul> <p>Also if the <code>decoding_method</code> is <code>sample</code>, then the following defaults are used:   - <code>temperature</code>: 0.7   - <code>top_p</code>: 0.85   - <code>top_k</code>: 50</p> <ul> <li> <p>Only simple GETs are supported for API calls currently (see example: <code>examples/hello/weather.json</code>). We plan to more fully support API calls in the future.</p> </li> <li> <p>The example <code>examples/react/React.json</code> is work-in-progress.</p> </li> </ul> <p>For a complete list of issues see here.</p>"},{"location":"#contributing-to-the-project","title":"Contributing to the Project","text":"<p>See Contributing to PDL</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#ast","title":"AST","text":""},{"location":"api_reference/#pdl.pdl_ast.AdvancedBlockType","title":"<code>AdvancedBlockType: TypeAlias = FunctionBlock | CallBlock | WatsonxModelBlock | BamModelBlock | CodeBlock | ApiBlock | GetBlock | DataBlock | IfBlock | RepeatBlock | RepeatUntilBlock | ForBlock | DocumentBlock | ReadBlock | IncludeBlock | ErrorBlock | EmptyBlock</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockType","title":"<code>BlockType: TypeAlias = str | AdvancedBlockType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlocksType","title":"<code>BlocksType: TypeAlias = BlockType | list[BlockType]</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ExpressionType","title":"<code>ExpressionType: TypeAlias = Any</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.MAX_NEW_TOKENS","title":"<code>MAX_NEW_TOKENS = 1024</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.MIN_NEW_TOKENS","title":"<code>MIN_NEW_TOKENS = 1</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ParserType","title":"<code>ParserType: TypeAlias = Literal['json', 'yaml'] | PdlParser | RegexParser</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.REPETITION_PENATLY","title":"<code>REPETITION_PENATLY = 1.05</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ScopeType","title":"<code>ScopeType: TypeAlias = dict[str, Any]</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.TEMPERATURE_SAMPLING","title":"<code>TEMPERATURE_SAMPLING = 0.7</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.TOP_K_SAMPLING","title":"<code>TOP_K_SAMPLING = 50</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.TOP_P_SAMPLING","title":"<code>TOP_P_SAMPLING = 0.85</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.empty_block_location","title":"<code>empty_block_location = LocationType(file='', path=[], table={})</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ApiBlock","title":"<code>ApiBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class ApiBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.API] = BlockKind.API\n    api: str\n    url: str\n    input: \"BlocksType\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.ApiBlock.api","title":"<code>api: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ApiBlock.input","title":"<code>input: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ApiBlock.kind","title":"<code>kind: Literal[BlockKind.API] = BlockKind.API</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ApiBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ApiBlock.url","title":"<code>url: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock","title":"<code>BamModelBlock</code>","text":"<p>               Bases: <code>ModelBlock</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class BamModelBlock(ModelBlock):\n    model_config = ConfigDict(extra=\"forbid\")\n    platform: Literal[ModelPlatform.BAM] = ModelPlatform.BAM\n    prompt_id: Optional[str] = None\n    parameters: Optional[PDLTextGenerationParameters] = None\n    moderations: Optional[ModerationParameters] = None\n    data: Optional[PromptTemplateData] = None\n    constraints: Any = None  # TODO\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.constraints","title":"<code>constraints: Any = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.data","title":"<code>data: Optional[PromptTemplateData] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.moderations","title":"<code>moderations: Optional[ModerationParameters] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.parameters","title":"<code>parameters: Optional[PDLTextGenerationParameters] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.platform","title":"<code>platform: Literal[ModelPlatform.BAM] = ModelPlatform.BAM</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BamModelBlock.prompt_id","title":"<code>prompt_id: Optional[str] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>PDL program block</p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class Block(BaseModel):\n    \"\"\"PDL program block\"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n    description: Optional[str] = None\n    spec: Any = None\n    defs: dict[str, \"BlocksType\"] = {}\n    assign: Optional[str] = Field(default=None, alias=\"def\")\n    show_result: bool = True\n    result: Optional[Any] = None\n    parser: Optional[ParserType] = None\n    location: Optional[LocationType] = None\n    has_error: bool = False\n    fallback: Optional[\"BlocksType\"] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.Block.assign","title":"<code>assign: Optional[str] = Field(default=None, alias='def')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.defs","title":"<code>defs: dict[str, BlocksType] = {}</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.description","title":"<code>description: Optional[str] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.fallback","title":"<code>fallback: Optional[BlocksType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.has_error","title":"<code>has_error: bool = False</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.location","title":"<code>location: Optional[LocationType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.parser","title":"<code>parser: Optional[ParserType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.result","title":"<code>result: Optional[Any] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.show_result","title":"<code>show_result: bool = True</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Block.spec","title":"<code>spec: Any = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind","title":"<code>BlockKind</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class BlockKind(StrEnum):\n    FUNCTION = \"function\"\n    CALL = \"call\"\n    MODEL = \"model\"\n    CODE = \"code\"\n    API = \"api\"\n    GET = \"get\"\n    DATA = \"data\"\n    DOCUMENT = \"document\"\n    IF = \"if\"\n    REPEAT = \"repeat\"\n    REPEAT_UNTIL = \"repeat_until\"\n    READ = \"read\"\n    INCLUDE = \"include\"\n    EMPTY = \"empty\"\n    FOR = \"for\"\n    ERROR = \"error\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.BlockKind.API","title":"<code>API = 'api'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.CALL","title":"<code>CALL = 'call'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.CODE","title":"<code>CODE = 'code'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.DATA","title":"<code>DATA = 'data'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.DOCUMENT","title":"<code>DOCUMENT = 'document'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.EMPTY","title":"<code>EMPTY = 'empty'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.ERROR","title":"<code>ERROR = 'error'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.FOR","title":"<code>FOR = 'for'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.FUNCTION","title":"<code>FUNCTION = 'function'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.GET","title":"<code>GET = 'get'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.IF","title":"<code>IF = 'if'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.INCLUDE","title":"<code>INCLUDE = 'include'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.MODEL","title":"<code>MODEL = 'model'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.READ","title":"<code>READ = 'read'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.REPEAT","title":"<code>REPEAT = 'repeat'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.BlockKind.REPEAT_UNTIL","title":"<code>REPEAT_UNTIL = 'repeat_until'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CallBlock","title":"<code>CallBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class CallBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.CALL] = BlockKind.CALL\n    call: str\n    args: dict[str, Any] = {}\n    trace: Optional[\"BlocksType\"] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.CallBlock.args","title":"<code>args: dict[str, Any] = {}</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CallBlock.call","title":"<code>call: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CallBlock.kind","title":"<code>kind: Literal[BlockKind.CALL] = BlockKind.CALL</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CallBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CallBlock.trace","title":"<code>trace: Optional[BlocksType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CodeBlock","title":"<code>CodeBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class CodeBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.CODE] = BlockKind.CODE\n    lan: Literal[\"python\", \"command\"]\n    code: \"BlocksType\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.CodeBlock.code","title":"<code>code: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CodeBlock.kind","title":"<code>kind: Literal[BlockKind.CODE] = BlockKind.CODE</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CodeBlock.lan","title":"<code>lan: Literal['python', 'command']</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.CodeBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.DataBlock","title":"<code>DataBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class DataBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.DATA] = BlockKind.DATA\n    data: ExpressionType\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.DataBlock.data","title":"<code>data: ExpressionType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.DataBlock.kind","title":"<code>kind: Literal[BlockKind.DATA] = BlockKind.DATA</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.DataBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.DocumentBlock","title":"<code>DocumentBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class DocumentBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.DOCUMENT] = BlockKind.DOCUMENT\n    document: \"BlocksType\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.DocumentBlock.document","title":"<code>document: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.DocumentBlock.kind","title":"<code>kind: Literal[BlockKind.DOCUMENT] = BlockKind.DOCUMENT</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.DocumentBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.EmptyBlock","title":"<code>EmptyBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class EmptyBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.EMPTY] = BlockKind.EMPTY\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.EmptyBlock.kind","title":"<code>kind: Literal[BlockKind.EMPTY] = BlockKind.EMPTY</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.EmptyBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ErrorBlock","title":"<code>ErrorBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class ErrorBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.ERROR] = BlockKind.ERROR\n    msg: str\n    program: \"BlocksType\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.ErrorBlock.kind","title":"<code>kind: Literal[BlockKind.ERROR] = BlockKind.ERROR</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ErrorBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ErrorBlock.msg","title":"<code>msg: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ErrorBlock.program","title":"<code>program: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ForBlock","title":"<code>ForBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class ForBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.FOR] = BlockKind.FOR\n    fors: dict[str, Any] = Field(alias=\"for\")\n    repeat: \"BlocksType\"\n    trace: Optional[list[\"BlocksType\"]] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.ForBlock.fors","title":"<code>fors: dict[str, Any] = Field(alias='for')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ForBlock.kind","title":"<code>kind: Literal[BlockKind.FOR] = BlockKind.FOR</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ForBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ForBlock.repeat","title":"<code>repeat: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ForBlock.trace","title":"<code>trace: Optional[list[BlocksType]] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.FunctionBlock","title":"<code>FunctionBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class FunctionBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.FUNCTION] = BlockKind.FUNCTION\n    function: Optional[dict[str, Any]]\n    returns: \"BlocksType\" = Field(..., alias=\"return\")\n    scope: Optional[ScopeType] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.FunctionBlock.function","title":"<code>function: Optional[dict[str, Any]]</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.FunctionBlock.kind","title":"<code>kind: Literal[BlockKind.FUNCTION] = BlockKind.FUNCTION</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.FunctionBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.FunctionBlock.returns","title":"<code>returns: BlocksType = Field(..., alias='return')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.FunctionBlock.scope","title":"<code>scope: Optional[ScopeType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.GetBlock","title":"<code>GetBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class GetBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.GET] = BlockKind.GET\n    get: str\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.GetBlock.get","title":"<code>get: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.GetBlock.kind","title":"<code>kind: Literal[BlockKind.GET] = BlockKind.GET</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.GetBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IfBlock","title":"<code>IfBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class IfBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.IF] = BlockKind.IF\n    condition: ExpressionType = Field(alias=\"if\")\n    then: \"BlocksType\"\n    elses: Optional[\"BlocksType\"] = Field(default=None, alias=\"else\")\n    if_result: Optional[bool] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.IfBlock.condition","title":"<code>condition: ExpressionType = Field(alias='if')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IfBlock.elses","title":"<code>elses: Optional[BlocksType] = Field(default=None, alias='else')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IfBlock.if_result","title":"<code>if_result: Optional[bool] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IfBlock.kind","title":"<code>kind: Literal[BlockKind.IF] = BlockKind.IF</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IfBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IfBlock.then","title":"<code>then: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IncludeBlock","title":"<code>IncludeBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class IncludeBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.INCLUDE] = BlockKind.INCLUDE\n    include: str\n    trace: Optional[\"BlockType\"] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.IncludeBlock.include","title":"<code>include: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IncludeBlock.kind","title":"<code>kind: Literal[BlockKind.INCLUDE] = BlockKind.INCLUDE</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IncludeBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.IncludeBlock.trace","title":"<code>trace: Optional[BlockType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.LocationType","title":"<code>LocationType</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class LocationType(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n    path: list[str]\n    file: str\n    table: dict[str, int]\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.LocationType.file","title":"<code>file: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.LocationType.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.LocationType.path","title":"<code>path: list[str]</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.LocationType.table","title":"<code>table: dict[str, int]</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ModelBlock","title":"<code>ModelBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class ModelBlock(Block):\n    kind: Literal[BlockKind.MODEL] = BlockKind.MODEL\n    model: str\n    input: Optional[\"BlocksType\"] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.ModelBlock.input","title":"<code>input: Optional[BlocksType] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ModelBlock.kind","title":"<code>kind: Literal[BlockKind.MODEL] = BlockKind.MODEL</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ModelBlock.model","title":"<code>model: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ModelPlatform","title":"<code>ModelPlatform</code>","text":"<p>               Bases: <code>StrEnum</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class ModelPlatform(StrEnum):\n    BAM = \"bam\"\n    WATSONX = \"watsonx\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.ModelPlatform.BAM","title":"<code>BAM = 'bam'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ModelPlatform.WATSONX","title":"<code>WATSONX = 'watsonx'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.PDLException","title":"<code>PDLException</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class PDLException(Exception):\n    def __init__(self, msg):\n        self.msg = msg\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.PDLException.msg","title":"<code>msg = msg</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.PDLException.__init__","title":"<code>__init__(msg)</code>","text":"Source code in <code>pdl/pdl_ast.py</code> <pre><code>def __init__(self, msg):\n    self.msg = msg\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.PDLTextGenerationParameters","title":"<code>PDLTextGenerationParameters</code>","text":"<p>               Bases: <code>TextGenerationParameters</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class PDLTextGenerationParameters(TextGenerationParameters):\n    model_config = ConfigDict(extra=\"forbid\")\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.PDLTextGenerationParameters.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Parser","title":"<code>Parser</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class Parser(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n    description: Optional[str] = None\n    spec: Optional[dict[str, Any]] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.Parser.description","title":"<code>description: Optional[str] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Parser.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Parser.spec","title":"<code>spec: Optional[dict[str, Any]] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.PdlBlock","title":"<code>PdlBlock</code>","text":"<p>               Bases: <code>RootModel</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class PdlBlock(RootModel):\n    # This class is used to introduce that a type in the generate JsonSchema\n    root: BlockType\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.PdlBlock.root","title":"<code>root: BlockType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.PdlBlocks","title":"<code>PdlBlocks</code>","text":"<p>               Bases: <code>RootModel</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class PdlBlocks(RootModel):\n    # This class is used to introduce that a type in the generate JsonSchema\n    root: BlocksType\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.PdlBlocks.root","title":"<code>root: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.PdlParser","title":"<code>PdlParser</code>","text":"<p>               Bases: <code>Parser</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class PdlParser(Parser):\n    model_config = ConfigDict(extra=\"forbid\")\n    pdl: \"BlocksType\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.PdlParser.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.PdlParser.pdl","title":"<code>pdl: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.Program","title":"<code>Program</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>Prompt Description Program (PDL)</p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class Program(RootModel):\n    \"\"\"\n    Prompt Description Program (PDL)\n    \"\"\"\n\n    # root: dict[str, BlockType]\n    root: BlockType\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.Program.root","title":"<code>root: BlockType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ReadBlock","title":"<code>ReadBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class ReadBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.READ] = BlockKind.READ\n    read: str | None\n    message: Optional[str] = None\n    multiline: bool = False\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.ReadBlock.kind","title":"<code>kind: Literal[BlockKind.READ] = BlockKind.READ</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ReadBlock.message","title":"<code>message: Optional[str] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ReadBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ReadBlock.multiline","title":"<code>multiline: bool = False</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.ReadBlock.read","title":"<code>read: str | None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RegexParser","title":"<code>RegexParser</code>","text":"<p>               Bases: <code>Parser</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class RegexParser(Parser):\n    model_config = ConfigDict(extra=\"forbid\")\n    regex: str\n    mode: Literal[\"search\", \"match\", \"fullmatch\", \"split\", \"findall\"] = \"fullmatch\"\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.RegexParser.mode","title":"<code>mode: Literal['search', 'match', 'fullmatch', 'split', 'findall'] = 'fullmatch'</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RegexParser.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RegexParser.regex","title":"<code>regex: str</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatBlock","title":"<code>RepeatBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class RepeatBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.REPEAT] = BlockKind.REPEAT\n    repeat: \"BlocksType\"\n    num_iterations: int\n    trace: Optional[list[\"BlocksType\"]] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.RepeatBlock.kind","title":"<code>kind: Literal[BlockKind.REPEAT] = BlockKind.REPEAT</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatBlock.num_iterations","title":"<code>num_iterations: int</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatBlock.repeat","title":"<code>repeat: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatBlock.trace","title":"<code>trace: Optional[list[BlocksType]] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatUntilBlock","title":"<code>RepeatUntilBlock</code>","text":"<p>               Bases: <code>Block</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class RepeatUntilBlock(Block):\n    model_config = ConfigDict(extra=\"forbid\")\n    kind: Literal[BlockKind.REPEAT_UNTIL] = BlockKind.REPEAT_UNTIL\n    repeat: \"BlocksType\"\n    until: ExpressionType\n    trace: Optional[list[\"BlocksType\"]] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.RepeatUntilBlock.kind","title":"<code>kind: Literal[BlockKind.REPEAT_UNTIL] = BlockKind.REPEAT_UNTIL</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatUntilBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatUntilBlock.repeat","title":"<code>repeat: BlocksType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatUntilBlock.trace","title":"<code>trace: Optional[list[BlocksType]] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.RepeatUntilBlock.until","title":"<code>until: ExpressionType</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.WatsonxModelBlock","title":"<code>WatsonxModelBlock</code>","text":"<p>               Bases: <code>ModelBlock</code></p> Source code in <code>pdl/pdl_ast.py</code> <pre><code>class WatsonxModelBlock(ModelBlock):\n    model_config = ConfigDict(extra=\"forbid\")\n    platform: Literal[ModelPlatform.WATSONX] = ModelPlatform.WATSONX\n    params: Optional[dict] = None\n    guardrails: Optional[bool] = None\n    guardrails_hap_params: Optional[dict] = None\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.WatsonxModelBlock.guardrails","title":"<code>guardrails: Optional[bool] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.WatsonxModelBlock.guardrails_hap_params","title":"<code>guardrails_hap_params: Optional[dict] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.WatsonxModelBlock.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.WatsonxModelBlock.params","title":"<code>params: Optional[dict] = None</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.WatsonxModelBlock.platform","title":"<code>platform: Literal[ModelPlatform.WATSONX] = ModelPlatform.WATSONX</code>","text":""},{"location":"api_reference/#pdl.pdl_ast.empty_text_generation_parameters","title":"<code>empty_text_generation_parameters()</code>","text":"Source code in <code>pdl/pdl_ast.py</code> <pre><code>def empty_text_generation_parameters() -&gt; PDLTextGenerationParameters:\n    return PDLTextGenerationParameters(\n        beam_width=None,\n        max_new_tokens=None,\n        min_new_tokens=None,\n        random_seed=None,\n        repetition_penalty=None,\n        stop_sequences=None,\n        temperature=None,\n        time_limit=None,\n        top_k=None,\n        top_p=None,\n        truncate_input_tokens=None,\n        typical_p=None,\n    )\n</code></pre>"},{"location":"api_reference/#pdl.pdl_ast.set_default_model_params","title":"<code>set_default_model_params(params)</code>","text":"Source code in <code>pdl/pdl_ast.py</code> <pre><code>def set_default_model_params(\n    params: Optional[PDLTextGenerationParameters],\n) -&gt; PDLTextGenerationParameters:\n    if params is None:\n        params = empty_text_generation_parameters()\n    if params.decoding_method is None:\n        params.decoding_method = (  # pylint: disable=attribute-defined-outside-init\n            DecodingMethod.GREEDY\n        )\n    if params.max_new_tokens is None:\n        params.max_new_tokens = (  # pylint: disable=attribute-defined-outside-init\n            MAX_NEW_TOKENS\n        )\n    if params.min_new_tokens is None:\n        params.min_new_tokens = (  # pylint: disable=attribute-defined-outside-init\n            MIN_NEW_TOKENS\n        )\n    if params.repetition_penalty is None:\n        params.repetition_penalty = (  # pylint: disable=attribute-defined-outside-init\n            REPETITION_PENATLY\n        )\n    if params.decoding_method == DecodingMethod.SAMPLE:\n        if params.temperature is None:\n            params.temperature = (  # pylint: disable=attribute-defined-outside-init\n                TEMPERATURE_SAMPLING\n            )\n        if params.top_k is None:\n            params.top_k = (  # pylint: disable=attribute-defined-outside-init\n                TOP_K_SAMPLING\n            )\n        if params.top_p is None:\n            params.top_p = (  # pylint: disable=attribute-defined-outside-init\n                TOP_P_SAMPLING\n            )\n    return params\n</code></pre>"},{"location":"api_reference/#interpreter","title":"Interpreter","text":""},{"location":"api_reference/#pdl.pdl_interpreter.__PDL_SESSION","title":"<code>__PDL_SESSION = types.SimpleNamespace()</code>","text":""},{"location":"api_reference/#pdl.pdl_interpreter.empty_scope","title":"<code>empty_scope: ScopeType = {'context': ''}</code>","text":""},{"location":"api_reference/#pdl.pdl_interpreter.InterpreterState","title":"<code>InterpreterState</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>class InterpreterState(BaseModel):\n    yield_output: bool = True\n    log: list[str] = []\n    batch: int = 0\n    # batch=0: streaming\n    # batch=1: call to generate with `input`\n\n    def with_yield_output(self: \"InterpreterState\", b: bool) -&gt; \"InterpreterState\":\n        return self.model_copy(update={\"yield_output\": b})\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.InterpreterState.batch","title":"<code>batch: int = 0</code>","text":""},{"location":"api_reference/#pdl.pdl_interpreter.InterpreterState.log","title":"<code>log: list[str] = []</code>","text":""},{"location":"api_reference/#pdl.pdl_interpreter.InterpreterState.yield_output","title":"<code>yield_output: bool = True</code>","text":""},{"location":"api_reference/#pdl.pdl_interpreter.InterpreterState.with_yield_output","title":"<code>with_yield_output(b)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def with_yield_output(self: \"InterpreterState\", b: bool) -&gt; \"InterpreterState\":\n    return self.model_copy(update={\"yield_output\": b})\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.PDLRuntimeParserError","title":"<code>PDLRuntimeParserError</code>","text":"<p>               Bases: <code>PDLException</code></p> Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>class PDLRuntimeParserError(PDLException):\n    pass\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.append_log","title":"<code>append_log(state, title, somestring)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def append_log(state: InterpreterState, title, somestring):\n    state.log.append(\"**********  \" + title + \"  **********\\n\")\n    state.log.append(str(somestring) + \"\\n\")\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.call_command","title":"<code>call_command(code)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def call_command(code: str) -&gt; tuple[int, str]:\n    args = shlex.split(code)\n    p = subprocess.run(args, capture_output=True, text=True, check=False)\n    if p.stderr != \"\":\n        print(p.stderr)\n    result = p.returncode\n    output = p.stdout\n    return result, output\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.call_python","title":"<code>call_python(code)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def call_python(code: str) -&gt; Any:\n    my_namespace = types.SimpleNamespace(PDL_SESSION=__PDL_SESSION)\n    exec(code, my_namespace.__dict__)\n    result = my_namespace.result\n    return result\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.children_contain_error","title":"<code>children_contain_error(block)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def children_contain_error(block: AdvancedBlockType) -&gt; bool:\n    try:\n        iter_block_children(_raise_on_error, block)\n        return False\n    except StopIteration:\n        return True\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.contains_error","title":"<code>contains_error(blocks)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def contains_error(blocks: BlocksType) -&gt; bool:\n    try:\n        iter_blocks(_raise_on_error, blocks)\n        return False\n    except StopIteration:\n        return True\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.generate","title":"<code>generate(pdl_file, log_file, initial_scope, output_mode, output_file)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def generate(\n    pdl_file: str,\n    log_file: Optional[str],\n    initial_scope: ScopeType,\n    output_mode: Optional[Literal[\"json\", \"yaml\"]],\n    output_file: Optional[str],\n):\n    if log_file is None:\n        log_file = \"log.txt\"\n    try:\n        prog, line_table = parse_program(pdl_file)\n        state = InterpreterState(yield_output=True)\n        loc = LocationType(path=[], file=pdl_file, table=line_table)\n        _, _, _, trace = process_prog(state, initial_scope, prog, loc)\n        with open(log_file, \"w\", encoding=\"utf-8\") as log_fp:\n            for line in state.log:\n                log_fp.write(line)\n        if output_mode is not None and trace is not None:\n            write_trace(pdl_file, output_mode, output_file, trace)\n    except PDLParseError as e:\n        print(\"\\n\".join(e.msg))\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.generate_client_response","title":"<code>generate_client_response(state, block, model, model_input)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def generate_client_response(  # pylint: disable=too-many-arguments\n    state: InterpreterState,\n    block: BamModelBlock | WatsonxModelBlock,\n    model: str,\n    model_input: str,\n) -&gt; Generator[YieldMessage, Any, str]:\n    match state.batch:\n        case 0:\n            output = yield from generate_client_response_streaming(\n                state, block, model, model_input\n            )\n        case 1:\n            output = yield from generate_client_response_single(\n                state, block, model, model_input\n            )\n        case _:\n            output = yield from generate_client_response_batching(\n                state, block, model, model_input\n            )\n    return output\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.generate_client_response_batching","title":"<code>generate_client_response_batching(state, block, model, model_input)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def generate_client_response_batching(  # pylint: disable=too-many-arguments\n    state: InterpreterState,\n    block: BamModelBlock | WatsonxModelBlock,\n    model: str,\n    model_input: str,\n) -&gt; Generator[YieldMessage, Any, str]:\n    match block:\n        case BamModelBlock():\n            text = yield ModelCallMessage(\n                model_id=model,\n                prompt_id=block.prompt_id,\n                model_input=model_input,\n                parameters=block.parameters,\n                moderations=block.moderations,\n                data=block.data,\n            )\n            if state.yield_output:\n                yield OutputMessage(text)\n        case WatsonxModelBlock():\n            assert False  # XXX TODO\n        case _:\n            assert False\n    return text\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.generate_client_response_single","title":"<code>generate_client_response_single(state, block, model, model_input)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def generate_client_response_single(\n    state: InterpreterState,\n    block: BamModelBlock | WatsonxModelBlock,\n    model: str,\n    model_input: str,\n) -&gt; Generator[YieldMessage, Any, str]:\n    text: str\n    match block:\n        case BamModelBlock():\n            text = BamModel.generate_text(\n                model_id=model,\n                prompt_id=block.prompt_id,\n                model_input=model_input,\n                parameters=block.parameters,\n                moderations=block.moderations,\n                data=block.data,\n            )\n        case WatsonxModelBlock():\n            text = WatsonxModel.generate_text(\n                model_id=model,\n                prompt=model_input,\n                params=block.params,\n                guardrails=block.guardrails,\n                guardrails_hap_params=block.guardrails_hap_params,\n            )\n    if state.yield_output:\n        yield OutputMessage(text)\n    return text\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.generate_client_response_streaming","title":"<code>generate_client_response_streaming(state, block, model, model_input)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def generate_client_response_streaming(\n    state: InterpreterState,\n    block: BamModelBlock | WatsonxModelBlock,\n    model: str,\n    model_input: str,\n) -&gt; Generator[YieldMessage, Any, str]:\n    text_stream: Generator[str, Any, None]\n    match block:\n        case BamModelBlock():\n            text_stream = BamModel.generate_text_stream(\n                model_id=model,\n                prompt_id=block.prompt_id,\n                model_input=model_input,\n                parameters=block.parameters,\n                moderations=block.moderations,\n                data=block.data,\n            )\n        case WatsonxModelBlock():\n            text_stream = WatsonxModel.generate_text_stream(\n                model_id=model,\n                prompt=model_input,\n                params=block.params,\n                guardrails=block.guardrails,\n                guardrails_hap_params=block.guardrails_hap_params,\n            )\n        case _:\n            assert False\n    text = \"\"\n    for chunk in text_stream:\n        if state.yield_output:\n            yield OutputMessage(chunk)\n        text += chunk\n    return text\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.get_var","title":"<code>get_var(var, scope)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def get_var(var: str, scope: ScopeType) -&gt; Any:\n    try:\n        segs = var.split(\".\")\n        res = scope[segs[0]]\n\n        for v in segs[1:]:\n            res = res[v]\n    except Exception:\n        return None\n    return res\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.handle_error","title":"<code>handle_error(block, loc, top_message, errors, subtrace)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def handle_error(\n    block: BlockType,\n    loc: LocationType,\n    top_message: Optional[str],\n    errors: list[str],\n    subtrace: BlocksType,\n) -&gt; ErrorBlock:\n    msg = \"\"\n    if top_message is not None:\n        msg += f\"{get_loc_string(loc)}{top_message}\\n\"\n    msg += \"\\n\".join(errors)\n    print(\"\\n\" + msg)\n    return ErrorBlock(msg=msg, program=subtrace)\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.parse_result","title":"<code>parse_result(parser, text)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def parse_result(parser: ParserType, text: str) -&gt; Optional[dict[str, Any] | list[Any]]:\n    result: Optional[dict[str, Any] | list[Any]]\n    match parser:\n        case \"json\":\n            try:\n                result = json.loads(text)\n            except Exception as exc:\n                raise PDLRuntimeParserError(\n                    \"Attempted to parse ill-formed JSON\"\n                ) from exc\n        case \"yaml\":\n            try:\n                result = yaml.safe_load(text)\n            except Exception as exc:\n                raise PDLRuntimeParserError(\n                    \"Attempted to parse ill-formed YAML\"\n                ) from exc\n        case PdlParser():\n            assert False, \"TODO\"\n        case RegexParser(mode=\"search\" | \"match\" | \"fullmatch\"):\n            regex = parser.regex\n            match parser.mode:\n                case \"search\":\n                    matcher = re.search\n                case \"match\":\n                    matcher = re.match\n                case \"fullmatch\":\n                    matcher = re.fullmatch\n                case _:\n                    assert False\n            m = matcher(regex, text, flags=re.M)\n            if m is None:\n                return None\n            if parser.spec is None:\n                result = list(m.groups())\n            else:\n                current_group_name = \"\"\n                try:\n                    result = {}\n                    for x in parser.spec.keys():\n                        current_group_name = x\n                        result[x] = m.group(x)\n                    return result\n                except IndexError as exc:\n                    msg = f\"No group named {current_group_name} found by {regex} in {text}\"\n                    raise PDLRuntimeParserError(msg) from exc\n        case RegexParser(mode=\"split\" | \"findall\"):\n            regex = parser.regex\n            match parser.mode:\n                case \"split\":\n                    result = re.split(regex, text, flags=re.M)\n                case \"findall\":\n                    result = re.findall(regex, text, flags=re.M)\n                case _:\n                    assert False\n        case _:\n            assert False\n    return result\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.process_condition","title":"<code>process_condition(scope, cond, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def process_condition(\n    scope: ScopeType, cond: ExpressionType, loc: LocationType\n) -&gt; tuple[bool, list[str]]:\n    b, errors = process_expr(scope, cond, loc)\n    return b, errors\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.process_expr","title":"<code>process_expr(scope, expr, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def process_expr(\n    scope: ScopeType, expr: Any, loc: LocationType\n) -&gt; tuple[Any, list[str]]:\n    if isinstance(expr, str):\n        template = Template(\n            expr,\n            keep_trailing_newline=True,\n            block_start_string=\"{%%%%%PDL%%%%%%%%%%\",\n            block_end_string=\"%%%%%PDL%%%%%%%%%%}\",\n            # comment_start_string=\"\",\n            # comment_end_string=\"\",\n            autoescape=False,\n            undefined=StrictUndefined,\n        )\n        try:\n            s = template.render(scope)\n            if expr.startswith(\"{{\") and expr.endswith(\"}}\"):\n                try:\n                    return literal_eval(s), []\n                except Exception:\n                    pass\n        except UndefinedError as e:\n            msg = f\"{get_loc_string(loc)}{e}\"\n            return (None, [msg])\n        return (s, [])\n    if isinstance(expr, list):\n        errors = []\n        result = []\n        for index, x in enumerate(expr):\n            res, errs = process_expr(scope, x, append(loc, \"[\" + str(index) + \"]\"))\n            if len(errs) != 0:\n                errors += errs\n            result.append(res)\n        return (result, errors)  # type: ignore\n    if isinstance(expr, dict):\n        errors = []\n        result_dict: dict[str, Any] = {}\n        for k, x in expr.items():\n            r, errs = process_expr(scope, x, append(loc, k))\n            if len(errs) != 0:\n                errors += errs\n            result_dict[k] = r\n        return (result_dict, errors)  # type: ignore\n    return (expr, [])\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.process_input","title":"<code>process_input(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def process_input(\n    state: InterpreterState, scope: ScopeType, block: ReadBlock, loc: LocationType\n) -&gt; tuple[str, ScopeType, ReadBlock | ErrorBlock]:\n    if block.read is not None:\n        with open(block.read, encoding=\"utf-8\") as f:\n            s = f.read()\n            append_log(state, \"Input from File: \" + block.read, s)\n    else:\n        message = \"\"\n        if block.message is not None:\n            message = block.message\n        elif block.multiline is False:\n            message = \"How can I help you?: \"\n        else:\n            message = \"Enter/Paste your content. Ctrl-D to save it.\"\n        if block.multiline is False:\n            s = input(message)\n            append_log(state, \"Input from stdin: \", s)\n        else:  # multiline\n            print(message)\n            contents = []\n            while True:\n                try:\n                    line = input()\n                except EOFError:\n                    break\n                contents.append(line + \"\\n\")\n            s = \"\".join(contents)\n            append_log(state, \"Input from stdin: \", s)\n    trace = block.model_copy(update={\"result\": s})\n    return s, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.process_prog","title":"<code>process_prog(state, initial_scope, prog, loc=empty_block_location)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def process_prog(\n    state: InterpreterState,\n    initial_scope: ScopeType,\n    prog: Program,\n    loc=empty_block_location,\n) -&gt; tuple[Any, str, ScopeType, BlockType]:\n    scope: ScopeType = empty_scope | initial_scope\n    doc_generator = step_block(state, scope, block=prog.root, loc=loc)\n    for result, document, scope, trace in schedule([doc_generator]):\n        return result, document, scope, trace\n    assert False\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.process_progs","title":"<code>process_progs(state, initial_scopes, prog, loc=empty_block_location)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def process_progs(\n    state: InterpreterState,\n    initial_scopes: Iterable[ScopeType],\n    prog: Program,\n    loc=empty_block_location,\n) -&gt; Iterable[tuple[Any, str, ScopeType, BlockType]]:\n    if state.batch &gt; 1:\n        batch_size = state.batch\n    else:\n        batch_size = 1\n    for batch in batched(initial_scopes, batch_size):\n        doc_generators = [\n            step_block(state, empty_scope | initial_scope, block=prog.root, loc=loc)\n            for initial_scope in batch\n        ]\n        for result, document, scope, trace in schedule(doc_generators):\n            yield result, document, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_advanced_block","title":"<code>step_advanced_block(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_advanced_block(\n    state: InterpreterState,\n    scope: ScopeType,\n    block: AdvancedBlockType,\n    loc: LocationType,\n) -&gt; Generator[YieldMessage, Any, tuple[Any, str, ScopeType, BlockType]]:\n    if len(block.defs) &gt; 0:\n        scope, defs_trace = yield from step_defs(state, scope, block.defs, loc)\n    else:\n        defs_trace = block.defs\n    state = state.with_yield_output(state.yield_output and block.show_result)\n    result, output, scope, trace = yield from step_block_body(state, scope, block, loc)\n    trace = trace.model_copy(update={\"defs\": defs_trace, \"result\": output})\n    if block.parser is not None:\n        try:\n            result = parse_result(block.parser, result)\n        except PDLRuntimeParserError as e:\n            trace = handle_error(block, loc, e.msg, [], trace)\n    if block.assign is not None:\n        var = block.assign\n        scope = scope | {var: result}\n    if block.show_result is False:\n        output = \"\"\n    if block.spec is not None and not isinstance(block, FunctionBlock):\n        errors = type_check_spec(result, block.spec, block.location)\n        if len(errors) &gt; 0:\n            trace = handle_error(\n                block, loc, \"Type errors during spec checking\", errors, trace\n            )\n    return result, output, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_block","title":"<code>step_block(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_block(\n    state: InterpreterState, scope: ScopeType, block: BlockType, loc: LocationType\n) -&gt; Generator[YieldMessage, Any, tuple[Any, str, ScopeType, BlockType]]:\n    result: Any\n    output: str\n    trace: BlockType\n    if isinstance(block, str):\n        result, errors = process_expr(scope, block, loc)\n        if len(errors) != 0:\n            trace = handle_error(block, loc, None, errors, block)\n            result = block\n            output = block\n        else:\n            output = stringify(result)\n            trace = output\n        if state.yield_output:\n            yield OutputMessage(output)\n        append_log(state, \"Document\", output)\n    else:\n        result, output, scope, trace = yield from step_advanced_block(\n            state, scope, block, loc\n        )\n    scope = scope | {\"context\": output}\n    return result, output, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_block_body","title":"<code>step_block_body(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_block_body(\n    state: InterpreterState,\n    scope: ScopeType,\n    block: AdvancedBlockType,\n    loc: LocationType,\n) -&gt; Generator[YieldMessage, Any, tuple[Any, str, ScopeType, AdvancedBlockType]]:\n    scope_init = scope\n    result: Any\n    output: str\n    trace: AdvancedBlockType\n    block.location = loc\n    match block:\n        case ModelBlock():\n            result, output, scope, trace = yield from step_call_model(\n                state, scope, block, loc\n            )\n        case CodeBlock():\n            result, output, scope, trace = yield from step_call_code(\n                state, scope, block, loc\n            )\n            if state.yield_output:\n                yield OutputMessage(output)\n        case GetBlock(get=var):\n            result = get_var(var, scope)\n            if result is None:\n                output = \"\"\n                trace = handle_error(\n                    block,\n                    append(loc, \"get\"),\n                    f\"Variable is undefined: {var}\",\n                    [],\n                    block.model_copy(),\n                )\n            else:\n                output = stringify(result)\n                trace = block.model_copy()\n            if state.yield_output:\n                yield OutputMessage(output)\n        case DataBlock(data=v):\n            block.location = append(loc, \"data\")\n            result, errors = process_expr(scope, v, append(loc, \"data\"))\n            if len(errors) != 0:\n                result = None\n                output = \"\"\n                trace = handle_error(\n                    block, append(loc, \"data\"), None, errors, block.model_copy()\n                )\n            else:\n                output = stringify(result)\n                trace = block.model_copy()\n            if state.yield_output:\n                yield OutputMessage(output)\n        case ApiBlock():\n            result, output, scope, trace = yield from step_call_api(\n                state, scope, block, loc\n            )\n            if state.yield_output:\n                yield OutputMessage(output)\n        case DocumentBlock():\n            _, output, scope, document = yield from step_blocks(\n                state, scope, block.document, append(loc, \"document\")\n            )\n            result = output\n            trace = block.model_copy(update={\"document\": document})\n        case IfBlock():\n            result = None\n            output = \"\"\n            b, errors = process_condition(scope, block.condition, append(loc, \"if\"))\n            if len(errors) != 0:\n                trace = handle_error(\n                    block, append(loc, \"if\"), None, errors, block.model_copy()\n                )\n            else:\n                if b:\n                    thenloc = append(loc, \"then\")\n                    result, output, scope, then_trace = yield from step_blocks(\n                        state, scope, block.then, thenloc\n                    )\n                    trace = block.model_copy(\n                        update={\n                            \"if_result\": b,\n                            \"then\": then_trace,\n                        }\n                    )\n                elif block.elses is not None:\n                    elseloc = append(loc, \"else\")\n                    result, output, scope, else_trace = yield from step_blocks(\n                        state, scope, block.elses, elseloc\n                    )\n                    trace = block.model_copy(\n                        update={\n                            \"if_result\": b,\n                            \"elses\": else_trace,\n                        }\n                    )\n                else:\n                    trace = block.model_copy(update={\"if_result\": b})\n        case RepeatBlock(num_iterations=n):\n            result = None\n            output = \"\"\n            iterations_trace: list[BlocksType] = []\n            context_init = scope_init[\"context\"]\n            for _ in range(n):\n                repeatloc = append(loc, \"repeat\")\n                scope = scope | {\"context\": context_init + output}\n                result, iteration_output, scope, body_trace = yield from step_blocks(\n                    state, scope, block.repeat, repeatloc\n                )\n                output += iteration_output\n                iterations_trace.append(body_trace)\n                if contains_error(body_trace):\n                    break\n            trace = block.model_copy(update={\"trace\": iterations_trace})\n        case ForBlock():\n            result = []\n            output = \"\"\n            iter_trace: list[BlocksType] = []\n            context_init = scope_init[\"context\"]\n            items: dict[str, Any] = {}\n            lengths = []\n            for k, v in block.fors.items():\n                klist: list[Any] = []\n                kloc = append(append(block.location, \"for\"), k)\n                klist, errors = process_expr(scope, v, kloc)\n                if len(errors) != 0:\n                    trace = handle_error(block, kloc, None, errors, block.model_copy())\n                if not isinstance(klist, list):\n                    trace = handle_error(\n                        block,\n                        kloc,\n                        \"Values inside the For block must be lists\",\n                        [],\n                        block.model_copy(),\n                    )\n                    klist = []\n                items = items | {k: klist}\n                lengths.append(len(klist))\n            if len(set(lengths)) != 1:  # Not all the lists are of the same length\n                trace = handle_error(\n                    block,\n                    append(block.location, \"for\"),\n                    \"Lists inside the For block must be of the same length\",\n                    [],\n                    block.model_copy(),\n                )\n            else:\n                for i in range(lengths[0]):\n                    scope = scope | {\"context\": context_init + output}\n                    for k in items.keys():\n                        scope = scope | {k: items[k][i]}\n                    newloc = append(loc, \"repeat\")\n                    (\n                        iteration_result,\n                        iteration_output,\n                        scope,\n                        body_trace,\n                    ) = yield from step_blocks(state, scope, block.repeat, newloc)\n                    output += iteration_output\n                    result.append(iteration_result)\n                    iter_trace.append(body_trace)\n                    if contains_error(body_trace):\n                        break\n                trace = block.model_copy(update={\"trace\": iter_trace})\n        case RepeatUntilBlock(until=cond):\n            result = None\n            stop = False\n            output = \"\"\n            iterations_trace = []\n            context_init = scope_init[\"context\"]\n            while not stop:\n                scope = scope | {\"context\": context_init + output}\n                repeatloc = append(loc, \"repeat\")\n                result, iteration_output, scope, body_trace = yield from step_blocks(\n                    state, scope, block.repeat, repeatloc\n                )\n                output += iteration_output\n                iterations_trace.append(body_trace)\n                if contains_error(body_trace):\n                    break\n                stop, errors = process_condition(scope, cond, append(loc, \"until\"))\n                if len(errors) != 0:\n                    trace = handle_error(\n                        block, append(loc, \"until\"), None, errors, block.model_copy()\n                    )\n                    iterations_trace.append(trace)\n                    break\n            trace = block.model_copy(update={\"trace\": iterations_trace})\n        case ReadBlock():\n            output, scope, trace = process_input(state, scope, block, loc)\n            if state.yield_output:\n                yield OutputMessage(output)\n            result = output\n\n        case IncludeBlock():\n            result, output, scope, trace = yield from step_include(\n                state, scope, block, loc\n            )\n\n        case FunctionBlock():\n            closure = block.model_copy()\n            if block.assign is not None:\n                scope = scope | {block.assign: closure}\n            closure.scope = scope\n            result = closure\n            output = \"\"\n            trace = closure.model_copy(update={})\n        case CallBlock(call=f):\n            result = None\n            output = \"\"\n            args, errors = process_expr(scope, block.args, append(loc, \"args\"))\n            if len(errors) != 0:\n                trace = handle_error(\n                    block, append(loc, \"args\"), None, errors, block.model_copy()\n                )\n            closure = get_var(f, scope)\n            if closure is None:\n                trace = handle_error(\n                    block,\n                    append(loc, \"call\"),\n                    f\"Function is undefined: {f}\",\n                    [],\n                    block.model_copy(),\n                )\n            else:\n                argsloc = append(loc, \"args\")\n                type_errors = type_check_args(args, closure.function, argsloc)\n                if len(type_errors) &gt; 0:\n                    trace = handle_error(\n                        block,\n                        argsloc,\n                        f\"Type errors during function call to {f}\",\n                        type_errors,\n                        block.model_copy(),\n                    )\n                else:\n                    f_body = closure.returns\n                    f_scope = closure.scope | {\"context\": scope[\"context\"]} | args\n                    funloc = LocationType(\n                        file=closure.location.file,\n                        path=closure.location.path + [\"return\"],\n                        table=loc.table,\n                    )\n                    result, output, _, f_trace = yield from step_blocks(\n                        state, f_scope, f_body, funloc\n                    )\n                    trace = block.model_copy(update={\"trace\": f_trace})\n                    if closure.spec is not None:\n                        errors = type_check_spec(result, closure.spec, funloc)\n                        if len(errors) &gt; 0:\n                            trace = handle_error(\n                                block,\n                                loc,\n                                f\"Type errors in result of function call to {f}\",\n                                errors,\n                                trace,\n                            )\n        case EmptyBlock():\n            result = \"\"\n            output = \"\"\n            trace = block.model_copy()\n\n        case _:\n            assert False, f\"Internal error: unsupported type ({type(block)})\"\n    if isinstance(trace, ErrorBlock) or children_contain_error(trace):\n        if block.fallback is None:\n            trace.has_error = True\n        else:\n            result, fallback_output, scope, fallback_trace = yield from step_blocks(\n                state,\n                scope,\n                blocks=block.fallback,\n                loc=append(loc, \"fallback\"),\n            )\n            output = output + fallback_output\n            trace.fallback = fallback_trace\n    return result, output, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_blocks","title":"<code>step_blocks(state, scope, blocks, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_blocks(\n    state: InterpreterState,\n    scope: ScopeType,\n    blocks: BlocksType,\n    loc: LocationType,\n) -&gt; Generator[YieldMessage, Any, tuple[Any, str, ScopeType, BlocksType]]:\n    result: Any\n    output: str\n    trace: BlocksType\n    if not isinstance(blocks, str) and isinstance(blocks, Sequence):\n        result = None\n        output = \"\"\n        trace = []\n        context_init = scope[\"context\"]\n        for i, block in enumerate(blocks):\n            scope = scope | {\"context\": context_init + output}\n            newloc = append(loc, \"[\" + str(i) + \"]\")\n            result, o, scope, t = yield from step_block(state, scope, block, newloc)\n            output += o\n            trace.append(t)  # type: ignore\n    else:\n        result, output, scope, trace = yield from step_block(state, scope, blocks, loc)\n    return result, output, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_call_api","title":"<code>step_call_api(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_call_api(\n    state: InterpreterState, scope: ScopeType, block: ApiBlock, loc: LocationType\n) -&gt; Generator[YieldMessage, Any, tuple[Any, str, ScopeType, ApiBlock | ErrorBlock]]:\n    _, input_str, _, input_trace = yield from step_blocks(\n        state.with_yield_output(False), scope, block.input, append(loc, \"input\")\n    )\n    input_str = block.url + input_str\n    try:\n        append_log(state, \"API Input\", input_str)\n        response = requests.get(input_str)\n        result = response.json()\n        output = stringify(result)\n        append_log(state, \"API Output\", output)\n        trace = block.model_copy(update={\"input\": input_trace})\n    except Exception as e:\n        trace = handle_error(\n            block,\n            loc,\n            f\"API error: {e}\",\n            [],\n            block.model_copy(update={\"input\": input_trace}),\n        )\n        result = None\n        output = \"\"\n    return result, output, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_call_code","title":"<code>step_call_code(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_call_code(\n    state: InterpreterState, scope: ScopeType, block: CodeBlock, loc: LocationType\n) -&gt; Generator[YieldMessage, Any, tuple[Any, str, ScopeType, CodeBlock | ErrorBlock]]:\n    _, code_s, _, code_trace = yield from step_blocks(\n        state.with_yield_output(False), scope, block.code, append(loc, \"code\")\n    )\n    append_log(state, \"Code Input\", code_s)\n    try:\n        match block.lan:\n            case \"python\":\n                result = call_python(code_s)\n                output = str(result)\n            case \"command\":\n                result, output = call_command(code_s)\n            case _:\n                trace = handle_error(\n                    block,\n                    append(loc, \"lan\"),\n                    f\"Unsupported language: {block.lan}\",\n                    [],\n                    block.model_copy(),\n                )\n                result = None\n                output = \"\"\n                return result, output, scope, trace\n    except Exception as e:\n        trace = handle_error(\n            block,\n            loc,\n            f\"Code error: {e}\",\n            [],\n            block.model_copy(update={\"code\": code_s}),\n        )\n        result = None\n        output = \"\"\n\n    append_log(state, \"Code Output\", result)\n    trace = block.model_copy(update={\"result\": result, \"code\": code_trace})\n    return result, output, scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_call_model","title":"<code>step_call_model(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_call_model(\n    state: InterpreterState,\n    scope: ScopeType,\n    block: BamModelBlock | WatsonxModelBlock,\n    loc: LocationType,\n) -&gt; Generator[\n    YieldMessage,\n    Any,\n    tuple[Any, str, ScopeType, BamModelBlock | WatsonxModelBlock | ErrorBlock],\n]:\n    if block.input is not None:  # If not implicit, then input must be a block\n        _, model_input, _, input_trace = yield from step_blocks(\n            state.with_yield_output(False), scope, block.input, append(loc, \"input\")\n        )\n    else:\n        model_input = scope[\"context\"]\n        input_trace = None\n    model, errors = process_expr(scope, block.model, append(loc, \"model\"))\n    if len(errors) != 0:\n        trace = handle_error(\n            block, loc, None, errors, block.model_copy(update={\"input\": input_trace})\n        )\n        return None, \"\", scope, trace\n    try:\n        append_log(state, \"Model Input\", model_input)\n        gen = yield from generate_client_response(state, block, model, model_input)\n        append_log(state, \"Model Output\", gen)\n        trace = block.model_copy(update={\"result\": gen, \"input\": input_trace})\n        return gen, gen, scope, trace\n    except Exception as e:\n        trace = handle_error(\n            block,\n            loc,\n            f\"Model error: {e}\",\n            [],\n            block.model_copy(update={\"input\": input_trace}),\n        )\n        return None, \"\", scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_defs","title":"<code>step_defs(state, scope, defs, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_defs(\n    state: InterpreterState,\n    scope: ScopeType,\n    defs: dict[str, BlocksType],\n    loc: LocationType,\n) -&gt; Generator[YieldMessage, Any, tuple[ScopeType, dict[str, BlocksType]]]:\n    defs_trace: dict[str, BlocksType] = {}\n    defloc = append(loc, \"defs\")\n    for x, blocks in defs.items():\n        newloc = append(defloc, x)\n        state = state.with_yield_output(False)\n        result, _, _, blocks_trace = yield from step_blocks(\n            state, scope, blocks, newloc\n        )\n        scope = scope | {x: result}\n        defs_trace[x] = blocks_trace\n    return scope, defs_trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.step_include","title":"<code>step_include(state, scope, block, loc)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def step_include(\n    state: InterpreterState,\n    scope: ScopeType,\n    block: IncludeBlock,\n    loc: LocationType,\n) -&gt; Generator[\n    YieldMessage, Any, tuple[Any, str, ScopeType, IncludeBlock | ErrorBlock]\n]:\n    try:\n        prog, line_table = parse_program(block.include)\n        newloc = LocationType(file=block.include, path=[], table=line_table)\n        result, output, scope, trace = yield from step_block(\n            state, scope, prog.root, newloc\n        )\n        include_trace = block.model_copy(update={\"trace\": trace})\n        return result, output, scope, include_trace\n    except PDLParseError as e:\n        trace = handle_error(\n            block,\n            append(loc, \"include\"),\n            f\"Attempting to include invalid yaml: {block.include}\",\n            e.msg,\n            block.model_copy(),\n        )\n        return None, \"\", scope, trace\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.stringify","title":"<code>stringify(result)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def stringify(result):\n    return result if isinstance(result, str) else json.dumps(result)\n</code></pre>"},{"location":"api_reference/#pdl.pdl_interpreter.write_trace","title":"<code>write_trace(pdl_file, mode, output_file, trace)</code>","text":"Source code in <code>pdl/pdl_interpreter.py</code> <pre><code>def write_trace(\n    pdl_file: str,\n    mode: Literal[\"json\", \"yaml\"],\n    output_file: Optional[str],\n    trace: BlockType,\n):\n    if output_file is None:\n        output_file = str(Path(pdl_file).with_suffix(\"\")) + f\"_result.{mode}\"\n    with open(output_file, \"w\", encoding=\"utf-8\") as fp:\n        match mode:\n            case \"json\":\n                json.dump(block_to_dict(trace), fp)\n            case \"yaml\":\n                dump_yaml(block_to_dict(trace), stream=fp)\n</code></pre>"},{"location":"contrib/","title":"Contributing to PDL","text":"<p>You can report issues or open a pull request (PR) to suggest changes. </p>"},{"location":"contrib/#reporting-an-issue","title":"Reporting an issue","text":"<p>To report an issue, or to suggest an idea for a change that you haven't had time to write-up yet: 1.  Review existing issues to see if a similar issue has been opened or discussed. 2.  Open an issue. Be sure to include any helpful information, such as your Kubernetes environment details, error messages, or logs that you might have.</p>"},{"location":"contrib/#suggesting-a-change","title":"Suggesting a change","text":"<p>To suggest a change to this repository, submit a pull request with the complete set of changes that you want to suggest. Before creating a PR, make sure that your changes pass all of the tests.</p> <p>The test suite can be executed with the following command in the top-level folder: <pre><code>pytest\n</code></pre></p> <p>Also, please make sure that your changes pass static checks such as code styles by executing the following command: <pre><code>pre-commit run --all-files\n</code></pre></p>"},{"location":"tutorial/","title":"PDL Language Tutorial","text":"<p>The following sections give a step-by-step overview of PDL language features. All the examples in this tutorial can be found in <code>examples/</code>.</p>"},{"location":"tutorial/#simple-document","title":"Simple document","text":"<p>The simplest PDL program is one that generates a small document (file):</p> <pre><code>description: Hello world!\ndocument:\n    Hello, world!\n</code></pre> <p>This program has a <code>description</code> field, which contains a title. It also has a <code>document</code> field, which can be either a string, a block, or a list of strings and blocks. A block is a recipe for how to obtain data (e.g., model call, code call, etc...). In this case, there are no calls to an LLM or other tools, and <code>document</code> consists of a simple string.</p> <p>To render the program into an actual document, we have a PDL interpreter that can be invoked as follows:</p> <pre><code>python3 -m pdl.pdl ./examples/hello/hello.yaml\n</code></pre> <p>This results in the following output:</p> <pre><code>Hello, world!\n</code></pre>"},{"location":"tutorial/#calling-an-llm","title":"Calling an LLM","text":"<pre><code>description: Hello world calling a model\ndocument:\n- Hello,\n- model: ibm/granite-20b-code-instruct-v2\n  parameters:\n    decoding_method: greedy\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true\n</code></pre> <p>In this program (file), the <code>document</code> starts with the word <code>Hello,</code>, and we call a model (<code>ibm/granite-20b-code-instruct-v2</code>) with this as input prompt.  The model is passed some parameters including the <code>decoding_method</code> and <code>stop_sequences</code>, which are to be included in the output. Since the <code>input</code> field is not specified in the model call, the entire document up that point is passed to the model as input context. </p> <p>In general, a model call accepts the same parameters as BAM's text generation interface, with the exception that we provide some default values when the following parameters are missing:   - <code>decoding_method</code>: <code>greedy</code>   - <code>max_new_tokens</code>: 1024   - <code>min_new_tokens</code>: 1   - <code>repetition_penalty</code>: 1.07</p> <p>Also if the <code>decoding_method</code> is <code>sample</code>, then the following defaults are used:   - <code>temperature</code>: 0.7   - <code>top_p</code>: 0.85   - <code>top_k</code>: 50</p> <p>The user can override these defaults by explicitly including them in the model call.</p> <p>When we execute this program using the interpreter, we obtain:</p> <pre><code>Hello, world!\n</code></pre> <p>where the portion <code>world!</code> has been generated by Granite.</p> <p>Here's another of model call that includes an <code>input</code> field: <pre><code>description: Hello world calling a model\ndocument:\n- \"Hello, \"\n- model: ibm/granite-20b-multilingual\n  input: \n    Translate 'the world' to French\n  parameters:\n    decoding_method: greedy\n</code></pre></p> <p>In this case, we make a call to a falcon model, and the input passed to the model is the sentence: <code>Translate 'the world' to French</code> and nothing else from the surrounding document. When we execute this program, we obtain:</p> <pre><code>Hello, Le monde\n</code></pre>"},{"location":"tutorial/#variable-definition-and-use","title":"Variable Definition and Use","text":"<p>Any block can have a variable definition using a <code>def: &lt;var&gt;</code> field. This means that the output of that block is assigned to the variable <code>&lt;var&gt;</code>, which may be reused at a later point in the document. </p> <p>Consider the following example (file):</p> <pre><code>description: Hello world with variable def and use\ndocument:\n- Hello,\n- model: ibm/granite-20b-code-instruct-v2\n  def: GEN\n  parameters:\n    decoding_method: greedy\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true\n- \"\\nGEN is equal to: {{ GEN }}\"\n</code></pre> <p>Here we assign the output of the model to variable <code>GEN</code> using the <code>def</code> field. The last line of the program prints out the value of <code>GEN</code>. Notice the notation <code>{{ }}</code> for accessing the value of a variable.</p> <p>When we execute this program, we obtain: <pre><code>Hello, world!\nGEN is equal to:  world!\n</code></pre></p>"},{"location":"tutorial/#model-chaining","title":"Model Chaining","text":"<p>In PDL, we can declaratively chain models together as in the following example (file):</p> <pre><code>description: Hello world with model chainings\ndocument:\n- Hello,\n- model: ibm/granite-20b-code-instruct-v2\n  parameters:\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true\n- \"\\nTranslate the above sentence to French\\n\"\n- model: ibm/granite-20b-multilingual\n</code></pre> <p>In this program, the first call is to a granite model to complete the sentence <code>Hello, world!</code>. The following block in the document prints out the sentence: <code>Translate the above sentence to French</code>. The final line of the program takes the entire document produced so far and passes it as input to a falcon model. Notice that the input passed to the falcon model is the document up to that point. This makes it easy to chain models together and continue building on previous interactions.</p> <p>When we execute this program, we obtain:</p> <pre><code>Hello, world!\nTranslate the above sentence to French\nBonjour, monde!\n</code></pre>"},{"location":"tutorial/#function-definition","title":"Function Definition","text":"<p>PDL also supports function definitions to make it easier to reuse code. Suppose we want to define a translation function that takes a string and calls a falcon model for the translation. This would be written in PDL as follows (file):</p> <pre><code>description: Hello world with functions\ndocument:\n- Hello,\n- model: ibm/granite-20b-code-instruct-v2\n  def: GEN\n  parameters:\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true\n- def: translate\n  function:\n    sentence: str\n    language: str\n  return:\n    - \"\\nTranslate the sentence '{{ sentence }}' to {{ language }}\\n\"\n    - model: ibm/granite-20b-multilingual\n- call: translate\n  args:\n    sentence: Hello,{{ GEN }}\n    language: French\n- call: translate\n  args:\n    sentence: Bye,{{ GEN }}\n    language: Spanish\n</code></pre> <p>In this program, the third block defines a function <code>translate</code> that takes as parameters <code>sentence</code> and <code>language</code>, both of which are of type string. The body of the function is defined by its <code>return</code> field. In this case, we formulate a translation prompt using the parameters and send it to a falcon model.</p> <p>The last two blocks are calls to this function, as indicated by <code>call: translate</code>. This block specifies the arguments to be passed. When we execute this program, we obtain:</p> <pre><code>Hello, world!\nTranslate the sentence 'Hello, world!' to French\nBonjour, monde!\nTranslate the sentence 'Bye, world!' to Spanish\nAdi\u00f3s, mundo!\n</code></pre> <p>A function only contributes to the output document when it is called. So the definition itself results in <code>\"\"</code>. When we call a function, we implicitly pass the current document context, and this is used as input to model calls inside the function body. In the above example, since the <code>input</code> field is omitted, the entire document produced at that point is passed as input to the falcon model. </p>"},{"location":"tutorial/#grouping-variable-definitions-in-defs","title":"Grouping Variable Definitions in Defs","text":"<p>In PDL, the above program can be written more neatly by grouping certain variable definitions into a <code>defs</code> section, as follows (file):</p> <pre><code>description: Hello world with functions\ndefs:\n  translate:\n    function:\n      sentence: str\n      language: str\n    return:\n      - \"\\nTranslate the sentence '{{ sentence }}' to {{ language }}\\n\"\n      - model: ibm/granite-20b-multilingual\ndocument:\n- Hello,\n- model: ibm/granite-20b-code-instruct-v2\n  def: GEN\n  parameters:\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true \n- call: translate\n  args:\n    sentence: Hello,{{ GEN }}\n    language: French\n- call: translate\n  args:\n    sentence: Bye,{{ GEN }}\n    language: Spanish\n</code></pre> <p>This program has the same output has the one from the previous section.</p> <p>Notice that moving the <code>GEN</code> variable in <code>defs</code> would change the semantics of the program. This is because that model call is dependent on its context. Since it does not have an <code>input</code> field, it depends on what was produced in the document up to that point. Moving it to <code>defs</code> means that it would be executed immediately with an empty context. </p>"},{"location":"tutorial/#muting-block-output-with-show_result","title":"Muting Block Output with Show_result","text":"<p>By default, when a PDL block is executed it produces a result that gets printed in the output document. It is possible to mute this feature by setting <code>show_result</code> to <code>false</code> for any block. This feature allows the computation of intermediate values that are not necessarily output in the document.</p> <p>Consider the same example as above, but with <code>show_result</code> set to <code>false</code> (file):</p> <pre><code>description: Hello world with functions\ndocument:\n- Hello,\n- model: ibm/granite-20b-code-instruct-v2\n  def: GEN\n  parameters:\n    stop_sequences:\n    - '!'\n    include_stop_sequence: true\n- def: translate\n  function:\n    sentence: str\n    language: str\n  return:\n    - \"\\nTranslate the sentence '{{ sentence }}' to {{ language }}\\n\"\n    - model: ibm/granite-20b-multilingual\n- call: translate\n  show_result: false\n  def: FRENCH\n  args:\n    sentence: Hello,{{ GEN }}\n    language: French\n- call: translate\n  args:\n    sentence: Bye,{{ GEN }}\n    language: Spanish\n- \"\\nThe french sentence was: {{ FRENCH }}\"\n</code></pre> <p>The call to the translator with French as language does not produce an output. However, we save the result in variable <code>FRENCH</code> and use it in the last sentence of the document. When we execute this program, we obtain:</p> <pre><code>Hello, world!\nTranslate the sentence 'Bye, world!' to Spanish\nNos vemos, mundo!\nThe french sentence was: Bonjour, monde!\n</code></pre>"},{"location":"tutorial/#input-from-file-or-stdin","title":"Input from File or Stdin","text":"<p>PDL can accept textual input from a file or stdin. In the following example (file), the contents of this file are read by PDL and incorporated in the document. The result is also assigned to a variable <code>HELLO</code>.</p> <pre><code>description: PDL code with input block\ndocument:\n- read: examples/input/data.txt\n  def: HELLO\n</code></pre> <p>In the next example, prompts are obtained from stdin (file). This is indicated by assigning the value <code>null</code> to the <code>read</code> field.</p> <pre><code>description: PDL code with input block\ndocument:\n- \"The following will prompt the user on stdin.\\n\"\n- read:\n  message: \"Please provide an input: \"\n  def: STDIN\n</code></pre> <p>Notice that when executing programs containing input blocks, the stdin input is obtained first and then the entire document is printed when produced. The document is not printed as it gets produced since there may be portions that are intermediate results and must be hidden (see <code>show_result</code> feature above). If the <code>message</code> field is omitted then one is provided for you.</p> <p>The following example shows a multiline stdin input (file). When executing this code and to exit from the multiline input simply press control D (macos). <pre><code>description: PDL code with input block\ndocument:\n- \"A multiline stdin input.\\n\"\n- read:\n  multiline: true\n</code></pre></p> <p>Finally, the following example shows reading content in JSON format. In this case the block's <code>assign</code> field must be defined since the block adds the JSON content in that format to the scope, assigning this content to the named variable.</p> <p>Consider the JSON content in this file: <pre><code>{\n    \"name\": \"Bob\",\n    \"address\": {\n        \"number\": 87,\n        \"street\": \"Smith Road\",\n        \"town\": \"Armonk\", \n        \"state\": \"NY\",\n        \"zip\": 10504\n    }\n}\n</code></pre></p> <p>The following PDL program reads this content and assigns it to variable <code>PERSON</code> in JSON format (file). The reference <code>PERSON.address.street</code> then refers to that field inside the JSON object.</p> <pre><code>description: Input block example with json input\ndocument:\n- read: tests/data/input.json\n  parser: json\n  def: PERSON\n  show_result: false\n- \"{{ PERSON.name }} lives at the following address:\\n\"\n- \"{{ PERSON.address.number }} {{ PERSON.address.street }} in the town of {{ PERSON.address.town }}, {{ PERSON.address.state }}\"\n</code></pre> <p>When we execute this program, we obtain: <pre><code>Bob lives at the following address:\n87 Smith Road in the town of Armonk, NY\n</code></pre></p>"},{"location":"tutorial/#calling-code","title":"Calling code","text":"<p>The following script shows how to execute python code (file). Currently, the python code is executed locally. In the future, we plan to use a serverless cloud engine to execute snippets of code. So in principle, PDL is agnostic of any specific programming language. The result of the code must be assigned to the variable <code>result</code> internally to be propagated to the result of the block.</p> <pre><code>description: Hello world showing call to python code\ndocument:\n- \"Hello, \"\n- lan: python\n  code: \n    |\n    import random\n    import string\n    result = random.choice(string.ascii_lowercase)\n</code></pre> <p>This results in the following output: <pre><code>Hello, r!\n</code></pre></p>"},{"location":"tutorial/#calling-apis","title":"Calling APIs","text":"<p>PDL programs can contain calls to REST APIs. Consider a simple weather app (file):</p> <pre><code>description: Using a weather API and LLM to make a small weather app\ndocument:\n- read:\n  def: QUERY\n  message: \"Ask a query: \"\n  show_result: false\n- model: ibm/granite-20b-code-instruct-v2\n  input:\n    document: |-\n      Question: What is the weather in London?\n      London\n      Question: What's the weather in Paris?\n      Paris\n      Question: Tell me the weather in Lagos?\n      Lagos\n      Question: {{ QUERY }}\n  parameters:\n    decoding_method: greedy\n    stop_sequences:\n    - Question\n    - What\n    - '!'\n    include_stop_sequence: false\n  def: LOCATION\n  show_result: false\n- api: https\n  url: https://api.weatherapi.com/v1/current.json?key=cf601276764642cb96224947230712&amp;q=\n  input: '{{ LOCATION }}'\n  def: WEATHER\n  show_result: false\n- model: ibm/granite-20b-code-instruct-v2\n  input: &gt;\n    Explain what the weather is from the following JSON:\n    `{{ WEATHER }}`\n  parameters:\n    decoding_method: greedy\n    max_new_tokens: 100\n    stop_sequences:\n    - What\n    - '!'\n    include_stop_sequence: false\n</code></pre> <p>In this program, we first prompt the user to enter a query about the weather in some location (assigned to variable <code>QUERY</code>). The next block is a call to a granite model with few-shot examples to extract the location, which we assign to variable <code>LOCATION</code>. The next block makes an API block. Currently we only support simple <code>GET</code> calls as shown above, but will improve this interface in the future. Here the <code>LOCATION</code> is appended to the <code>url</code>. The result is a JSON object, which may be hard to interpret for a human user. So we make a final call to an LLM to interpret the JSON in terms of weather. Notice how many blocks have <code>show_result</code> set to <code>false</code> to hide intermediate results.</p> <p>Here is an example of interaction with this program: <pre><code>Ask a query: What is the weather in Anchorage?\n\nAnswer: The weather in Anchorage, Alaska, United States of America is currently overcast with a temperature of -2.8\u00b0C (-5.0\u00b0F). The wind speed is 4.3 mph (6.8 kph) and the humidity is 66%.\n</code></pre></p>"},{"location":"tutorial/#data-block","title":"Data Block","text":"<p>PDL offers the ability to create JSON data as illustrated by the following example (described in detail in the Overview section). The <code>data</code> block can gather previously defined variables into a JSON structure. This feature is useful for data generation. Programs such as this one can be bootstrapped with a bash or Python script to generate data en masse. (file)</p> <pre><code>description: Code explanation example\ndocument:\n- read: examples/code/data.json\n  parser: json\n  def: CODE\n  show_result: False\n- read: examples/code/ground_truth.txt\n  def: TRUTH\n  show_result: False\n- model: ibm/granite-20b-code-instruct-v2\n  def: EXPLANATION\n  show_result: False\n  parameters:\n    decoding_method: greedy\n    max_new_tokens: 1024\n  input:\n     |\n      Here is some info about the location of the function in the repo.\n      repo: \n      {{ CODE.repo_info.repo }}\n      path: {{ CODE.repo_info.path }}\n      Function_name: {{ CODE.repo_info.function_name }}\n\n\n      Explain the following code:\n      ```\n      {{ CODE.source_code }}```\n- def: EVAL\n  show_result: False\n  lan: python\n  code:\n    |\n    import textdistance\n    expl = \"\"\"\n    {{ EXPLANATION }}\n    \"\"\"\n    truth = \"\"\"\n    {{ TRUTH }}\n    \"\"\"\n    result = textdistance.levenshtein.normalized_similarity(expl, truth)\n- data:\n    input: \"{{ CODE }}\"\n    output: \"{{ EXPLANATION }}\"\n    metric: \"{{ EVAL }}\"\n</code></pre>"},{"location":"tutorial/#include-block","title":"Include Block","text":"<p>PDL allows programs to be defined over multiple files. The <code>include</code> block allows one file to incorporate another, as shown in the following example:</p> <pre><code>description: Business Rules extraction from Jsp pages\ndefs:\n  PROMPTS2: \n    | \n    Convert above provided JSP code into business rules. Response should be in plain English and should not include any code. Do not output anything other than response. Please extract and summarize all the business rules in the below 5 categories:\n      -Data Retrieval\n      -User Interface\n      -Results Display\n      -JavaScript\n  PROMPTS2_NOTES:\n  - |\n\n    * Strictly include all relevant parameters related to each of the above categories\n\ndocument:\n  - include: examples/consultant/function.yaml\n  - call: template\n    args:\n      preamble: \"jsp: {{ input_data }}\"\n      question: \"{{ PROMPTS2 }}\"\n      notes: \"{{ PROMPTS2_NOTES }}\"\n</code></pre> <p>which includes the following file:</p> <pre><code>description: Function definition\ndefs:\n  template:\n    function:\n      preamble: str\n      question: str\n      notes: str\n    return:\n    - |\n      {{ preamble }}\n      ### Question: {{ question }}\n\n      ### Notes:\n      {{ notes }}\n\n      ### Answer: \ndocument: \"\"\n</code></pre> <p>The <code>include</code> block means that the PDL code at that file is executed and its output is included at the point where the <code>include</code> block appears in a document. In this example, the file contains a function definition, which is used in the first program as a template. This feature allows reuse of common templates and patterns and to build libraries.</p>"},{"location":"tutorial/#conditionals-and-loops","title":"Conditionals and Loops","text":"<p>PDL supports conditionals and loops as illustrated in the followin example (file).</p> <p>The task at hand is to generate math problems that look like the following:</p> <pre><code>Question: Noah charges $60 for a large painting and $30 for a small painting.\nLast month he sold eight large paintings and four small paintings.\nIf he sold twice as much this month, how much is his sales for this month?\n\nAnswer: Let's think step by step.\nHe sold 8 large paintings and 4 small paintings last month.\nHe sold twice as many this month.\n8 large paintings x $60 = &lt;&lt; 8*60= 480 &gt;&gt; 480\n4 small paintings x $30 = &lt;&lt; 4*30= 120 &gt;&gt; 120\nSo he sold &lt;&lt; 480+120= 600 &gt;&gt; 600 paintings last month.\nTherefore he sold &lt;&lt; 600*2= 1200 &gt;&gt; this month.\nThe answer is $1200.\n</code></pre> <p>We want the LLM to generate a math problem after <code>Question</code>, then generate an <code>Answer</code> with step-by-step reasoning. In the answer there may be arithmetic expressions. As we know that LLMs sometimes make mistakes with arithmentic, we wish to use Python to computer all arithmetic expressions in the answer. In the example above, generation should stop at <code>&lt;&lt;</code> symbols, then generate an arithmetic expression, followed by an <code>=</code> sign. At that point, we want to switch to Python and compute the expression as code, print the result and continue generation. This process should repeat until the model generates the phrase <code>The answer is</code>.</p> <p>The following PDL program captures this task:</p> <pre><code>description: Arithmetic Expressions\ndocument:\n- read: examples/arith/example1.txt\n- read: examples/arith/example2.txt\n- repeat:\n  - \"\\nQuestion: \"\n  - def: QUESTION\n    model: ibm/granite-20b-code-instruct-v2\n    parameters:\n      stop_sequences:\n      - Answer\n      include_stop_sequence: false\n  - \"Answer: Let's think step by step.\\n\"\n  - repeat:\n    - def: REASON_OR_CALC\n      model: ibm/granite-20b-code-instruct-v2\n      parameters:\n        stop_sequences:\n        - '&lt;&lt;'\n        include_stop_sequence: true\n    - if: '{{ REASON_OR_CALC.endswith(\"&lt;&lt;\") }}'\n      then:\n      - def: EXPR\n        model: ibm/granite-20b-code-instruct-v2\n        parameters:\n          stop_sequences:\n          - '='\n          - \"\\n\"\n          include_stop_sequence: false\n      - '= '\n      - def: RESULT\n        lan: python\n        code:\n        - result = {{ EXPR }}\n      - ' &gt;&gt;'\n    until: '{{ \"The answer is\" in REASON_OR_CALC }}'\n\n  - \"\\n\\n\"\n  num_iterations: 3\n</code></pre> <p>The first two blocks read math problem examples and include them in the document. These will be our few-shot examples. The next block is a repetion as indicated by the fields: <code>repeat</code> and the accompanying <code>num_iterations</code>. The field <code>repeat</code> can contain any document (string or block or list of strings and blocks), the <code>num_iterations</code> indicates how many times to repeat.</p> <p>In the body of the <code>repeat</code> block, the program first asks granite to generate a question and add it to the document. Next we print <code>Answer: Let's think step by step.\\n</code>. The following block is a repeat-until: the document in <code>repeat</code> is repeated until the condition in the <code>until</code> field becomes true. Here the condition states that we stop the iteration when variable <code>REASON_OR_CALC</code> contains <code>&lt;&lt;</code>. That variable is defined in the first block of the repeat-until -- we prompt a granite model and stop at the character <code>&lt;&lt;</code>.</p> <p>The next block is an if-then-else. We check if <code>REASON_OR_CALC</code> ends with <code>&lt;&lt;</code> and if so we prepare for the python call to perform the arithmetic calculation. First, we have the granite model generate an <code>EXPR</code> variable, which we then use inside the <code>code</code> of the following Python block. </p> <p>When we execute this program, we obtain 3 math problems like the ones in the examples. Try it! </p>"},{"location":"tutorial/#for-loops","title":"For Loops","text":"<p>PDL also offers <code>for</code> loops over lists. The following example simply prints each value in the list followed by a newline:</p> <pre><code>description: for loop\ndocument:\n- for:\n    i: [1, 2, 3, 4]\n  repeat: \n    \"{{ i }}\\n\"\n</code></pre> <p>The <code>for</code> loop constructs also allows iterating over 2 or more lists of the same length simultaneously:</p> <pre><code>description: for loop\ndefs:\n  numbers: {\n    data: [1, 2, 3, 4]\n  }\n  names: {\n    data: [\"Bob\", \"Carol\", \"David\", \"Ernest\"]\n  }\n\ndocument:\n- for:\n    number: \"{{ numbers }}\"\n    name: \"{{ names }}\"\n  repeat:\n    \"{{ name }}'s number is {{ number }}\\n\"\n</code></pre> <p>This results in the following output:</p> <pre><code>Bob's number is 1\nCarol's number is 2\nDavid's number is 3\nErnest's number is 4\n</code></pre>"},{"location":"tutorial/#debugging-pdl-programs","title":"Debugging PDL Programs","text":"<p>We highly recommend to use VSCode to edit PDL YAML files. This project has been configured so that every YAML file is associated with the PDL grammar JSONSchema (see settings and schema). This enables the editor to display error messages when the yaml deviates from the PDL syntax and grammar. It also provides code completion. You can set up your own VSCode PDL projects similarly using this settings and schema files. The PDL interpreter also provides similar error messages.</p> <p>The interpreter prints out a log by default in the file <code>log.txt</code>. This log contains the details of inputs and outputs to every block in the program. It is useful to examine this file when the program is behaving differently than expected.</p> <p>To change the log filename, you can pass it to the interpreter as follows:</p> <pre><code>python3 -m pdl.pdl --log &lt;my-logfile&gt; &lt;my-example&gt;\n</code></pre>"},{"location":"tutorial/#calling-pdl-programmatically-from-python","title":"Calling PDL Programmatically from Python","text":"<p>[[ TODO ]]</p>"},{"location":"tutorial/#visualization-with-the-live-document","title":"Visualization with the Live Document","text":"<p>[[ TODO ]]</p>"},{"location":"tutorial/#pdl-code-assistant","title":"PDL Code Assistant","text":"<p>[[ TODO ]]</p>"},{"location":"viewer/","title":"PDL Live Viewer","text":"<p>Note</p> <p>This is a demo of the PDL live viewer with a preloaded example. In practice, the user supplies a JSON trace generated by the PDL interpreter. The left pane contains the final \"document\", and upon interaction, the right pane displays the PDL that created that part of the document, along with a breakdown of the PDL blocks on the left pane. This tool makes debugging &amp; iterating PDL programs faster &amp; easier.</p> <p></p>"}]}