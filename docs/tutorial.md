

# PDL Language Tutorial

The following sections give a step-by-step overview of PDL language features.

## Simple document

The simplest PDL program is one that generates a small document:

```
description: Hello world!
document:
    Hello, world!
```

This program has a `description` field, which contains a title. It also has a `document` field, which can be either a string, a *block*, or a list of strings and blocks. A block is a recipe for how to obtain data (e.g., model call, code call, etc...). In this case, there are no calls to an LLM or other tools, and `document` consists of a simple string.

To render the program into an actual document, we have a PDL interpreter that can be invoked as follows:

```
python3 -m pdl.pdl ./examples/hello/hello.yaml
```

This results in the following output:

```
Hello, world!
```

## Calling an LLM

```
description: Hello world calling a model
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v1
  parameters:
    decoding_method: greedy
    stop_sequences:
    - '!'
    include_stop_sequence: true
```

In this program, the `document` starts with the word `Hello,`, and we call a model (`ibm/granite-20b-code-instruct-v1`) with this as input prompt. 
The model is passed some parameters including the `decoding_method` and `stop_sequences`, which are to be included in the output. Since the `input` field is not specified in the model call, the entire document up that point is passed to the model as input context. 

In general, a model call accepts the same parameters as BAM's [text generation](https://bam.res.ibm.com/docs/api-reference#text-generation) interface, with the exception that we provide some default values when the following parameters are missing:
  - `decoding_method`: `greedy`
  - `max_new_tokens`: 1024
  - `min_new_tokens`: 1
  - `repetition_penalty`: 1.07

The user can override these defaults by explicitly including them in the model call.

When we execute this program using the interpreter, we obtain:

```
Hello, world!
```

where the portion ` world!` has been generated by Granite.

Here's another of model call that includes an `input` field:
```
description: Hello world calling a model
document:
- "Hello, "
- model: ibm/falcon-40b-8lang-instruct
  input: 
    Translate 'the world' to French
  parameters:
    decoding_method: greedy
```

In this case, we make a call to a falcon model, and the input passed to the model is the sentence: `Translate 'the world' to French` and nothing else from the surrounding document. When we execute this program, we obtain:

```
Hello, Le monde
```

## Variable definition and use

Any block can have a variable definition using a `def: <var>` field. This means that the output of that block is assigned to the variable `<var>`, which may be reused at a later point in the document. 

Consider the following example:

```
description: Hello world with variable def and use
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v1
  def: GEN
  parameters:
    decoding_method: greedy
    stop_sequences:
    - '!'
    include_stop_sequence: true
- "\nGEN is equal to: {{{ GEN }}}"
```

Here we assign the output of the model to variable `GEN` using the `def` field. The last line of the program prints out the value of `GEN`. Notice the notation `{{{ }}}` for accessing the value of a variable.

When we execute this program, we obtain:
```
Hello, world!
GEN is equal to:  world!
```

## Model chaining

In PDL, we can declaratively chain models together as in the following example:

```
description: Hello world with model chainings
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v1
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true
- "\nTranslate the above sentence to French\n"
- model: ibm/falcon-40b-8lang-instruct
```

In this program, the first call is to a granite model to complete the sentence `Hello, world!`. The following block in the document prints out the sentence: `Translate the above sentence to French`. The final line of the program takes the entire document produced so far and passes it as input to a falcon model. Notice that the input passed to the falcon model is the document up to that point. This makes it easy to chain models together and continue building on previous interactions.

When we execute this program, we obtain:

```
Hello, world!
Translate the above sentence to French
Bonjour, monde!
```



## Function definition

PDL also supports function definitions to make it easier to reuse code.
Suppose we want to define a translation function that takes a string and calls a falcon model for the translation. This would be written in PDL as follows:

```
description: Hello world with functions
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v1
  def: GEN
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true
- def: translate
  params:
    sentence: str
    language: str
  document:
    - "\nTranslate the sentence '{{{ sentence }}}' to {{{ language }}}\n"
    - model: ibm/falcon-40b-8lang-instruct
- call: translate
  args:
    sentence: Hello,{{{ GEN }}}
    language: French
- call: translate
  args:
    sentence: Bye,{{{ GEN }}}
    language: Spanish
```

In this program, the third block defines a function `translate` that takes as parameters `sentence` and `language`, both of which are of type string. The body of the function is defined by its inner `document` field. In this case, we formulate a translation prompt using the parameters and send it to a falcon model.

The last two blocks are calls to this function, as indicated by `call: translate`. This block specifies the arguments to be passed. When we execute this program, we obtain:

```
Hello, world!
Translate the sentence 'Hello, world!' to French
Bonjour, monde!
Translate the sentence 'Bye, world!' to Spanish
Adiós, mundo!
```

A function only contributes to the output document when it is called. So the definition itself results in `""`. When we call a function, we implicitly pass the current document context, and this is used as input to model calls inside the function body. In the above example, since the `input` field is omitted, the entire document produced at that point is passed as input to the falcon model. 

## Show_result

By default, when a PDL block is executed it produces a result that gets printed in the output document. It is possible to mute this feature by setting `show_result` to `false` for any block. This feature allows the computation of intermediate values that are not necessarily output in the document.

Consider the same example as above, but with `show_result` set to `false`:

```
description: Hello world with functions
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v1
  def: GEN
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true
- def: translate
  params:
    sentence: str
    language: str
  document:
    - "\nTranslate the sentence '{{{ sentence }}}' to {{{ language }}}\n"
    - model: ibm/falcon-40b-8lang-instruct
- call: translate
  show_result: false
  def: FRENCH
  args:
    sentence: Hello,{{{ GEN }}}
    language: French
- call: translate
  args:
    sentence: Bye,{{{ GEN }}}
    language: Spanish
- "\nThe french sentence was: {{{ FRENCH }}}"
```

The call to the translator with French as language does not produce an output. However, we save the result in variable `FRENCH` and use it in the last sentence of the document. When we execute this program, we obtain:

```
Hello, world!
Translate the sentence 'Bye, world!' to Spanish
Nos vemos, mundo!
The french sentence was: Bonjour, monde!
```

## Input

PDL can accept textual input from a file or stdin. In the following example, the contents of this [file](../examples/input/data.txt) are read by PDL and incorporated in the document. The result is also assigned to a variable `HELLO`.

```
description: PDL code with input block
document:
- read: examples/input/data.txt
  def: HELLO
```

In the next example, prompts are obtained from stdin. This is indicated by assigning the value `null` to the `read` field.

```
description: PDL code with input block
document:
- "The following will prompt the user on stdin.\n"
- read:
  message: "Please provide an input: "
  def: STDIN
```

Notice that when executing programs containing input blocks, the stdin input is obtained first and then the entire document is printed when produced. The document is not printed as it gets produced since there may be portions that are intermediate results and must be hidden (see `show_result` feature above). If the `message` field is omitted then one is provided for you.

The following example shows a multiline stdin input. When executing this code and to exit from the multiline input simply press control D (macos).
```
description: PDL code with input block
document:
- "A multiline stdin input.\n"
- read:
  multiline: true
```

Finally, the following example shows reading content in JSON format. In this case the block's `assign` field must be defined since the block adds the JSON content in that format to the scope, assigning this content to the named variable.

Consider the JSON content in this [file](../tests/data/input.json):
```
{
    "name": "Bob",
    "address": {
        "number": 87,
        "street": "Smith Road",
        "town": "Armonk", 
        "state": "NY",
        "zip": 10504
    }
}
```

The following PDL program reads this content and assigns it to variable `PERSON` in JSON format. The reference `PERSON.address.street` then refers
to that field inside the JSON object.

```
description: Input block example with json input
document:
- read: tests/data/input.json
  parser: json
  def: PERSON
  show_result: false
- "{{{ PERSON.name }}} lives at the following address:\n"
- "{{{ PERSON.address.number }}} {{{ PERSON.address.street }}} in the town of {{{ PERSON.address.town }}}, {{{ PERSON.address.state }}}"
```

When we execute this program, we obtain:
```
Bob lives at the following address:
87 Smith Road in the town of Armonk, NY
```


## Calling code

The following script shows how to execute python code. Currently, the python code is executed locally. In the future, we plan to use a serverless cloud engine to execute snippets of code. So in principle, PDL is agnostic of any specific programming language. The result of the code must be assigned to the variable `result` internally to be propagated to the result of the block.

```
description: Hello world showing call to python code
document:
- "Hello, "
- lan: python
  code: 
    |
    import random
    import string
    result = random.choice(string.ascii_lowercase)
```

This results in the following output:
```
Hello, r!
```

## Calling APIs

PDL programs can contain calls to REST APIs. Consider a simple [weather app](../examples/hello/weather.yaml).

```
description: Using a weather API and LLM to make a small weather app
document:
- read:
  def: QUERY
  message: "Ask a query: "
  show_result: false
- model: ibm/granite-20b-code-instruct-v1
  input:
    document: |-
      Question: What is the weather in London?
      London
      Question: What's the weather in Paris?
      Paris
      Question: Tell me the weather in Lagos?
      Lagos
      Question: {{{ QUERY }}}
  parameters:
    decoding_method: greedy
    stop_sequences:
    - Question
    - What
    - '!'
    include_stop_sequence: false
  def: LOCATION
  show_result: false
- api: https
  url: https://api.weatherapi.com/v1/current.json?key=cf601276764642cb96224947230712&q=
  input: '{{{ LOCATION }}}'
  def: WEATHER
  show_result: false
- model: ibm/granite-20b-code-instruct-v1
  input: >
    Explain what the weather is from the following JSON:
    `{{{ WEATHER }}}`
  parameters:
    decoding_method: greedy
    max_new_tokens: 100
    stop_sequences:
    - What
    - '!'
    include_stop_sequence: false
```

In this program, we first prompt the user to enter a query about the weather in some location (assigned to variable `QUERY`). The next block is a call to a granite model with few-shot examples to extract the location, which we assign to variable `LOCATION`. The next block makes an API block. Currently we only support simple `GET` calls as shown above. Here the `LOCATION` is appended to the `url`. The result is a JSON object, which may be hard to interpret for a human user. So we make a final call to an LLM to interpret the JSON in terms of weather. Notice how many blocks have `show_result` set to `false` to hide intermediate results.

Here is an example of interaction with this program:
```
Ask a query: What is the weather in Anchorage?

Answer: The weather in Anchorage, Alaska, United States of America is currently overcast with a temperature of -2.8°C (-5.0°F). The wind speed is 4.3 mph (6.8 kph) and the humidity is 66%.
```


## Conditionals and Loops

PDL supports conditionals and loops as illustrated in this [example](../examples/arith/Arith-new.yaml).

[[TODO]]

## Debugging PDL Programs

We highly recommend to use VSCode to edit PDL YAML files. This project has been configured so that every YAML file is associated with the PDL grammar JSONSchema (see [settings](.vscode/settings.json) and [schema](pdl-schema.json)). This enables the editor to display error messages when the yaml deviates from the PDL syntax and grammar. It also provides code completion. You can set up your own VSCode PDL projects similarly using this settings and schema files. The PDL interpreter also provides similar error messages.

The interpreter prints out a log by default in the file `log.txt`. This log contains the details of inputs and outputs to every block in the program. It is useful to examine this file when the program is behaving differently than expected.

To change the log filename, you can pass it to the interpreter as follows:

```
python3 -m pdl.pdl --log <my-logfile> <my-example>
```

## PDL Code Assistant

[[ TODO ]]









