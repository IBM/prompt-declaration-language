

# PDL Language Tutorial

The following sections give a step-by-step overview of PDL language features.
All the examples in this tutorial can be found in `examples/`.


##  Simple document

The simplest PDL program is one that generates a small document ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/simple_program.pdl)):

```yaml
description: Hello world!
document:
    Hello, world!
```

This program has a `description` field, which contains a title. It also has a `document` field, which can be either a string, a *block*, or a list of strings and blocks. A block is a recipe for how to obtain data (e.g., model call, code call, etc...). In this case, there are no calls to an LLM or other tools, and `document` consists of a simple string.

To render the program into an actual document, we have a PDL interpreter that can be invoked as follows:

```
python3 -m pdl.pdl ./examples/hello/hello.pdl
```

This results in the following output:

```
Hello, world!
```

##  Calling an LLM

```yaml
description: Hello world calling a model
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v2
  parameters:
    decoding_method: greedy
    stop_sequences:
    - '!'
    include_stop_sequence: true
```

In this program ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/calling_llm.pdl)), the `document` starts with the word `Hello,`, and we call a model (`ibm/granite-20b-code-instruct-v2`) with this as input prompt. 
The model is passed some parameters including the `decoding_method` and `stop_sequences`, which are to be included in the output. Since the `input` field is not specified in the model call, the entire document up that point is passed to the model as input context. 

In general, a model call accepts the same parameters as BAM's [text generation](https://bam.res.ibm.com/docs/api-reference#text-generation) interface, with the exception that we provide some default values when the following parameters are missing:
  - `decoding_method`: `greedy`
  - `max_new_tokens`: 1024
  - `min_new_tokens`: 1
  - `repetition_penalty`: 1.07

Also if the `decoding_method` is `sample`, then the following defaults are used:
  - `temperature`: 0.7
  - `top_p`: 0.85
  - `top_k`: 50

The user can override these defaults by explicitly including them in the model call.

When we execute this program using the interpreter, we obtain:

```
Hello, world!
```

where the portion ` world!` has been generated by Granite.

Here's another of model call that includes an `input` field:
```yaml
description: Hello world calling a model
document:
- "Hello, "
- model: ibm/granite-20b-multilingual
  input: 
    Translate 'the world' to French
  parameters:
    decoding_method: greedy
```

In this case, we make a call to a falcon model, and the input passed to the model is the sentence: `Translate 'the world' to French` and nothing else from the surrounding document. When we execute this program, we obtain:

```
Hello, Le monde
```

##  Strings

Multiline strings are commonly used when writing PDL programs. However, their exact semantics are not intuitive. There are two types of formats that YAML supports for strings: block scalar and flow scalar formats. Scalars are what YAML calls basic values like numbers or strings, as opposed to complex types like arrays or objects. Block scalars have more control over how they are interpreted, whereas flow scalars have more limited escaping support. (Explanation here is thanks to [Wolfgang Faust](https://yaml-multiline.info/))

### Block Scalars

**Block Style Indicator**: The block style indicates how newlines inside the block should behave. If you would like them to be **kept** as newlines, use the literal style, indicated by a pipe `|`. Note that without a chomping indicator, described next, only the _last_ newline is kept.

PDL:
```
document:
  - |
    Several lines of text,
    with some "quotes" of various 'types',
    and also a blank line:
    
    and some text with
        extra indentation
    on the next line,
    plus another line at the end.
    
    
  - "End."
```

Output:
```
Several lines of text,
with some "quotes" of various 'types',
and also a blank line:

and some text with
    extra indentation
on the next line,
plus another line at the end.
End.
```

If instead you want them to be replaced by spaces, use the folded style, indicated by a right angle bracket `>`. To get a newline using the folded style, leave a blank line by putting _two_ newlines in. Lines with extra indentation are also not folded.

PDL:
```
document:
  - >
    Several lines of text,
    with some "quotes" of various 'types',
    and also a blank line:
    
    and some text with
        extra indentation
    on the next line,
    plus another line at the end.
    
    
  - "End."
```

Output:
```
Several lines of text, with some "quotes" of various 'types', and also a blank line:
and some text with
    extra indentation
on the next line, plus another line at the end.
End.
```

**Block Chomping Indicator**: The chomping indicator controls what should happen with newlines at the end of the string. The default, clip, puts a single newline at the end of the string. To remove all newlines, strip them by putting a minus sign `-` after the style indicator. Both clip and strip ignore how many newlines are actually at the end of the block; to keep them all put a plus sign `+` after the style indicator.

PDL:
```
document:
  - |-
    Several lines of text,
    with some "quotes" of various 'types',
    and also a blank line:
    
    and some text with
        extra indentation
    on the next line,
    plus another line at the end.
    
    
  - "End."
```

Output:
```
Several lines of text,
with some "quotes" of various 'types',
and also a blank line:

and some text with
    extra indentation
on the next line,
plus another line at the end.End.
```

PDL:
```
document:
  - |+
    Several lines of text,
    with some "quotes" of various 'types',
    and also a blank line:
    
    and some text with
        extra indentation
    on the next line,
    plus another line at the end.
    
    
  - "End."
```

Output:
```
Several lines of text,
with some "quotes" of various 'types',
and also a blank line:

and some text with
    extra indentation
on the next line,
plus another line at the end.


End.
```

If you don't have enough newline characters using the above methods, you can always add more like so:
```
document:
  - |-
    Several lines of text,
    with some "quotes" of various 'types',
    and also a blank line:
    
    and some text with
        extra indentation
    on the next line,
    plus another line at the end.
    
    
  - "\n\n\n\n"
  - "End."
```

Output:
```
Several lines of text,
with some "quotes" of various 'types',
and also a blank line:

and some text with
    extra indentation
on the next line,
plus another line at the end.



End.
```

**Indentation Indicator**: Ordinarily, the number of spaces you're using to indent a block will be automatically guessed from its first line. You may need a block indentation indicator if the first line of the block starts with extra spaces. In this case, simply put the number of spaces used for indentation (between 1 and 9) at the end of the header.

PDL:
```
document:
  - |1
    Several lines of text,
    with some "quotes" of various 'types',
    and also a blank line:
    
    and some text with
        extra indentation
    on the next line.
```

Output:
```
 Several lines of text,
 with some "quotes" of various 'types',
 and also a blank line:

 and some text with
     extra indentation
 on the next line.
```

### Flow Scalars

**Single-quoted**:

PDL:

```
document: 'Several lines of text,
  containing ''single quotes''. Escapes (like \n) don''t do anything.
  
  Newlines can be added by leaving a blank line.
    Leading whitespace on lines is ignored.'
```

Output:

```
Several lines of text, containing 'single quotes'. Escapes (like \n) don't do anything.
Newlines can be added by leaving a blank line. Leading whitespace on lines is ignored.
```

**Double-quoted**:

PDL:

```
document: "Several lines of text,
  containing \"double quotes\". Escapes (like \\n) work.\nIn addition,
  newlines can be esc\
  aped to prevent them from being converted to a space.
  
  Newlines can also be added by leaving a blank line.
    Leading whitespace on lines is ignored."
```

Output:

```
Several lines of text, containing "double quotes". Escapes (like \n) work.
In addition, newlines can be escaped to prevent them from being converted to a space.
Newlines can also be added by leaving a blank line. Leading whitespace on lines is ignored.
```

**Plain**:

PDL:

```
document: Several lines of text,
  with some "quotes" of various 'types'.
  Escapes (like \n) don't do anything.
  
  Newlines can be added by leaving a blank line.
    Additional leading whitespace is ignored.
```

Output:

```
Several lines of text, with some "quotes" of various 'types'. Escapes (like \n) don't do anything.
Newlines can be added by leaving a blank line. Additional leading whitespace is ignored.
```

##  Variable Definition and Use

Any block can have a variable definition using a `def: <var>` field. This means that the output of that block is assigned to the variable `<var>`, which may be reused at a later point in the document. 

Consider the following example ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/variable_def_use.pdl)):

```yaml
description: Hello world with variable def and use
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v2
  def: GEN
  parameters:
    decoding_method: greedy
    stop_sequences:
    - '!'
    include_stop_sequence: true
- "\nGEN is equal to: {{ GEN }}"
```

Here we assign the output of the model to variable `GEN` using the `def` field. The last line of the program prints out the value of `GEN`. Notice the notation `{{ }}` for accessing the value of a variable.

When we execute this program, we obtain:
```
Hello, world!
GEN is equal to:  world!
```

##  Model Chaining

In PDL, we can declaratively chain models together as in the following example ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/model_chaining.pdl)):

```yaml
description: Hello world with model chainings
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v2
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true
- "\nTranslate the above sentence to French\n"
- model: ibm/granite-20b-multilingual
```

In this program, the first call is to a granite model to complete the sentence `Hello, world!`. The following block in the document prints out the sentence: `Translate the above sentence to French`. The final line of the program takes the entire document produced so far and passes it as input to a falcon model. Notice that the input passed to the falcon model is the document up to that point. This makes it easy to chain models together and continue building on previous interactions.

When we execute this program, we obtain:

```
Hello, world!
Translate the above sentence to French
Bonjour, monde!
```



## Function Definition

PDL also supports function definitions to make it easier to reuse code.
Suppose we want to define a translation function that takes a string and calls a falcon model for the translation. This would be written in PDL as follows ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/function_definition.pdl)):

```yaml
description: Hello world with functions
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v2
  def: GEN
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true
- def: translate
  function:
    sentence: str
    language: str
  return:
    - "\nTranslate the sentence '{{ sentence }}' to {{ language }}\n"
    - model: ibm/granite-20b-multilingual
- call: translate
  args:
    sentence: Hello,{{ GEN }}
    language: French
- call: translate
  args:
    sentence: Bye,{{ GEN }}
    language: Spanish
```

In this program, the third block defines a function `translate` that takes as parameters `sentence` and `language`, both of which are of type string. The body of the function is defined by its `return` field. In this case, we formulate a translation prompt using the parameters and send it to a falcon model.

The last two blocks are calls to this function, as indicated by `call: translate`. This block specifies the arguments to be passed. When we execute this program, we obtain:

```
Hello, world!
Translate the sentence 'Hello, world!' to French
Bonjour, monde!
Translate the sentence 'Bye, world!' to Spanish
Adiós, mundo!
```

A function only contributes to the output document when it is called. So the definition itself results in `""`. When we call a function, we implicitly pass the current document context, and this is used as input to model calls inside the function body. In the above example, since the `input` field is omitted, the entire document produced at that point is passed as input to the falcon model. 

##  Grouping Variable Definitions in Defs

In PDL, the above program can be written more neatly by grouping certain variable definitions into a `defs` section, as follows ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/grouping_definitions.pdl)):

```yaml
description: Hello world with functions
defs:
  translate:
    function:
      sentence: str
      language: str
    return:
      - "\nTranslate the sentence '{{ sentence }}' to {{ language }}\n"
      - model: ibm/granite-20b-multilingual
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v2
  def: GEN
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true 
- call: translate
  args:
    sentence: Hello,{{ GEN }}
    language: French
- call: translate
  args:
    sentence: Bye,{{ GEN }}
    language: Spanish

```

This program has the same output has the one from the previous section.

Notice that moving the `GEN` variable in `defs` would change the semantics of the program. This is because that model call is dependent on its context. Since it does not have an `input` field, it depends on what was produced in the document up to that point. Moving it to `defs` means that it would be executed immediately with an empty context. 



##  Muting Block Output with Show_result

By default, when a PDL block is executed it produces a result that gets printed in the output document. It is possible to mute this feature by setting `show_result` to `false` for any block. This feature allows the computation of intermediate values that are not necessarily output in the document. The value of the variable specified in `def` is still set to the result of the block.

Consider the same example as above, but with `show_result` set to `false` ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/muting_block_output.pdl)):

```yaml
description: Hello world with functions
document:
- Hello,
- model: ibm/granite-20b-code-instruct-v2
  def: GEN
  parameters:
    stop_sequences:
    - '!'
    include_stop_sequence: true
- def: translate
  function:
    sentence: str
    language: str
  return:
    - "\nTranslate the sentence '{{ sentence }}' to {{ language }}\n"
    - model: ibm/granite-20b-multilingual
- call: translate
  show_result: false
  def: FRENCH
  args:
    sentence: Hello,{{ GEN }}
    language: French
- call: translate
  args:
    sentence: Bye,{{ GEN }}
    language: Spanish
- "\nThe french sentence was: {{ FRENCH }}"
```

The call to the translator with French as language does not produce an output. However, we save the result in variable `FRENCH` and use it in the last sentence of the document. When we execute this program, we obtain:

```
Hello, world!
Translate the sentence 'Bye, world!' to Spanish
Nos vemos, mundo!
The french sentence was: Bonjour, monde!
```

An important detail to be mindful of is where `show_result` is set. Here is an example of mistake that is easy to make:
```
description: Test
document:
  - def: NAME
    document:
      - model: "ibm/granite-20b-code-instruct-v2"
        show_result: false # <-- MISTAKE:
        # `show_result` is specified on the document,
        # resulting in an _empty_ document and thus
        # an empty `NAME`
        platform: bam
        input: Hello,
        parameters:
          decoding_method: "greedy"
          stop_sequences:
            - "!"
          include_stop_sequence: false
  - "The variable will be empty: `"
  - get: NAME
  - "`!\n"
  - def: TWO
    show_result: false # <-- CORRECT:
    # `show_result` is set at the root of the block,
    # which behaves as expected.
    document:
      - model: "ibm/granite-20b-code-instruct-v2"
        platform: bam
        input: Hello,
        parameters:
          decoding_method: "greedy"
          stop_sequences:
            - "!"
          include_stop_sequence: false
  - "But not this one: `"
  - get: TWO
  - "`!\n"
```

The output is:
```
The variable will be empty: ``!
But not this one: ` world`!
```

##  Input from File or Stdin

PDL can accept textual input from a file or stdin. In the following example ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/input_file.pdl)), the contents of this [file](https://github.ibm.com/ml4code/pdl/blob/main/examples/input/data.txt) are read by PDL and incorporated in the document. The result is also assigned to a variable `HELLO`.


```yaml
description: PDL code with input block
document:
- read: examples/input/data.txt
  def: HELLO
```

In the next example, prompts are obtained from stdin ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/input_stdin.pdl)). This is indicated by assigning the value `null` to the `read` field.

```yaml
description: PDL code with input block
document:
- "The following will prompt the user on stdin.\n"
- read:
  message: "Please provide an input: "
  def: STDIN
```

Notice that when executing programs containing input blocks, the stdin input is obtained first and then the entire document is printed when produced. The document is not printed as it gets produced since there may be portions that are intermediate results and must be hidden (see `show_result` feature above). If the `message` field is omitted then one is provided for you.

The following example shows a multiline stdin input ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/input_stdin_multiline.pdl)). When executing this code and to exit from the multiline input simply press control D (macos).
```yaml
description: PDL code with input block
document:
- "A multiline stdin input.\n"
- read:
  multiline: true
```

Finally, the following example shows reading content in JSON format. In this case the block's `assign` field must be defined since the block adds the JSON content in that format to the scope, assigning this content to the named variable.

Consider the JSON content in this [file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/input.json):
```json
{
    "name": "Bob",
    "address": {
        "number": 87,
        "street": "Smith Road",
        "town": "Armonk", 
        "state": "NY",
        "zip": 10504
    }
}
```

The following PDL program reads this content and assigns it to variable `PERSON` in JSON format ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/input_file_json.pdl)). The reference `PERSON.address.street` then refers to that field inside the JSON object.

```yaml
description: Input block example with json input
document:
- read: examples/tutorial/input.json
  parser: json
  def: PERSON
  show_result: false
- "{{ PERSON.name }} lives at the following address:\n"
- "{{ PERSON.address.number }} {{ PERSON.address.street }} in the town of {{ PERSON.address.town }}, {{ PERSON.address.state }}"
```

When we execute this program, we obtain:
```
Bob lives at the following address:
87 Smith Road in the town of Armonk, NY
```


##  Calling code

The following script shows how to execute python code ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/calling_code.pdl)). Currently, the python code is executed locally. In the future, we plan to use a serverless cloud engine to execute snippets of code. So in principle, PDL is agnostic of any specific programming language. Variables defined in PDL are copied into the global scope of the Python code, as such, mutating variables in Python has no effect on the variables in the document. The result of the code must be assigned to the variable `result` internally to be propagated to the result of the block.

```yaml
description: Hello world showing call to python code
document:
- "Hello, "
- lan: python
  code: 
    |
    import random
    import string
    result = random.choice(string.ascii_lowercase)
```

This results in the following output:
```
Hello, r!
```

## Calling APIs

PDL programs can contain calls to REST APIs. Consider a simple weather app ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/calling_apis.pdl)):

```yaml
description: Using a weather API and LLM to make a small weather app
document:
- read:
  def: QUERY
  message: "Ask a query: "
  show_result: false
- model: ibm/granite-20b-code-instruct-v2
  input:
    document: |-
      Question: What is the weather in London?
      London
      Question: What's the weather in Paris?
      Paris
      Question: Tell me the weather in Lagos?
      Lagos
      Question: {{ QUERY }}
  parameters:
    decoding_method: greedy
    stop_sequences:
    - Question
    - What
    - '!'
    include_stop_sequence: false
  def: LOCATION
  show_result: false
- api: https
  url: https://api.weatherapi.com/v1/current.json?key=cf601276764642cb96224947230712&q=
  input: '{{ LOCATION }}'
  def: WEATHER
  show_result: false
- model: ibm/granite-20b-code-instruct-v2
  input: >
    Explain what the weather is from the following JSON:
    `{{ WEATHER }}`
  parameters:
    decoding_method: greedy
    max_new_tokens: 100
    stop_sequences:
    - What
    - '!'
    include_stop_sequence: false
```

In this program, we first prompt the user to enter a query about the weather in some location (assigned to variable `QUERY`). The next block is a call to a granite model with few-shot examples to extract the location, which we assign to variable `LOCATION`. The next block makes an API block. Currently we only support simple `GET` calls as shown above, but will improve this interface in the future. Here the `LOCATION` is appended to the `url`. The result is a JSON object, which may be hard to interpret for a human user. So we make a final call to an LLM to interpret the JSON in terms of weather. Notice how many blocks have `show_result` set to `false` to hide intermediate results.

Here is an example of interaction with this program:
```
Ask a query: What is the weather in Anchorage?

Answer: The weather in Anchorage, Alaska, United States of America is currently overcast with a temperature of -2.8°C (-5.0°F). The wind speed is 4.3 mph (6.8 kph) and the humidity is 66%.
```

##  Data Block

PDL offers the ability to create JSON data as illustrated by the following example (described in detail in the [Overview](https://github.ibm.com/ml4code/pdl/blob/main/README.md#overview) section). The `data` block can gather previously defined variables into a JSON structure. This feature is useful for data generation. Programs such as this one can be bootstrapped with a bash or Python script to generate data en masse. ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/data_block.pdl))

```yaml
description: Code explanation example
document:
- read: examples/code/data.json
  parser: json
  def: CODE
  show_result: False
- read: examples/code/ground_truth.txt
  def: TRUTH
  show_result: False
- model: ibm/granite-20b-code-instruct-v2
  def: EXPLANATION
  show_result: False
  parameters:
    decoding_method: greedy
    max_new_tokens: 1024
  input:
     |
      Here is some info about the location of the function in the repo.
      repo: 
      {{ CODE.repo_info.repo }}
      path: {{ CODE.repo_info.path }}
      Function_name: {{ CODE.repo_info.function_name }}


      Explain the following code:
      ```
      {{ CODE.source_code }}```
- def: EVAL
  show_result: False
  lan: python
  code:
    |
    import textdistance
    expl = """
    {{ EXPLANATION }}
    """
    truth = """
    {{ TRUTH }}
    """
    result = textdistance.levenshtein.normalized_similarity(expl, truth)
- data:
    input: "{{ CODE }}"
    output: "{{ EXPLANATION }}"
    metric: "{{ EVAL }}"
```

## Include Block

PDL allows programs to be defined over multiple files. The `include` block allows one file to incorporate another, as shown in the
following [example](https://github.ibm.com/ml4code/pdl/blob/main/examples/consultant/biz_rules_extraction.pdl):

```
description: Business Rules extraction from Jsp pages
defs:
  PROMPTS2: 
    | 
    Convert above provided JSP code into business rules. Response should be in plain English and should not include any code. Do not output anything other than response. Please extract and summarize all the business rules in the below 5 categories:
      -Data Retrieval
      -User Interface
      -Results Display
      -JavaScript
  PROMPTS2_NOTES:
  - |
    
    * Strictly include all relevant parameters related to each of the above categories

document:
  - include: examples/consultant/function.pdl
  - call: template
    args:
      preamble: "jsp: {{ input_data }}"
      question: "{{ PROMPTS2 }}"
      notes: "{{ PROMPTS2_NOTES }}"
```

which includes the following [file](https://github.ibm.com/ml4code/pdl/blob/main/examples/consultant/function.pdl):

```
description: Function definition
defs:
  template:
    function:
      preamble: str
      question: str
      notes: str
    return:
    - |
      {{ preamble }}
      ### Question: {{ question }}

      ### Notes:
      {{ notes }}

      ### Answer: 
document: ""
```

The `include` block means that the PDL code at that file is executed and its output is included at the point where the `include` block appears in a document. In this example, the file contains a function definition, which is used in the first program as a template. This feature allows reuse of common templates and patterns and to build libraries.


##  Conditionals and Loops

PDL supports conditionals and loops as illustrated in the followin example ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/conditionals_loops.pdl)).

The task at hand is to generate math problems that look like the [following](https://github.ibm.com/ml4code/pdl/blob/main/examples/arith/example1.txt):

```
Question: Noah charges $60 for a large painting and $30 for a small painting.
Last month he sold eight large paintings and four small paintings.
If he sold twice as much this month, how much is his sales for this month?

Answer: Let's think step by step.
He sold 8 large paintings and 4 small paintings last month.
He sold twice as many this month.
8 large paintings x $60 = << 8*60= 480 >> 480
4 small paintings x $30 = << 4*30= 120 >> 120
So he sold << 480+120= 600 >> 600 paintings last month.
Therefore he sold << 600*2= 1200 >> this month.
The answer is $1200.
```

We want the LLM to generate a math problem after `Question`, then generate an `Answer` with step-by-step reasoning. In the answer there may be arithmetic expressions. As we know that LLMs sometimes make mistakes with arithmentic, we wish to use Python to computer all arithmetic expressions in the answer. In the example above, generation should stop at `<<` symbols, then generate an arithmetic expression, followed by an `=` sign. At that point, we want to switch to Python and compute the expression as code, print the result and continue generation. This process should repeat until the model generates the phrase `The answer is`.

The following PDL program captures this task:

```yaml
description: Arithmetic Expressions
document:
- read: examples/arith/example1.txt
- read: examples/arith/example2.txt
- repeat:
  - "\nQuestion: "
  - def: QUESTION
    model: ibm/granite-20b-code-instruct-v2
    parameters:
      stop_sequences:
      - Answer
      include_stop_sequence: false
  - "Answer: Let's think step by step.\n"
  - repeat:
    - def: REASON_OR_CALC
      model: ibm/granite-20b-code-instruct-v2
      parameters:
        stop_sequences:
        - '<<'
        include_stop_sequence: true
    - if: '{{ REASON_OR_CALC.endswith("<<") }}'
      then:
      - def: EXPR
        model: ibm/granite-20b-code-instruct-v2
        parameters:
          stop_sequences:
          - '='
          - "\n"
          include_stop_sequence: false
      - '= '
      - def: RESULT
        lan: python
        code:
        - result = {{ EXPR }}
      - ' >>'
    until: '{{ "The answer is" in REASON_OR_CALC }}'
    
  - "\n\n"
  num_iterations: 3
```

The first two blocks read math problem examples and include them in the document. These will be our few-shot examples. The next block is a repetion as indicated by the fields: `repeat` and the accompanying `num_iterations`. The field `repeat` can contain any document (string or block or list of strings and blocks), the `num_iterations` indicates how many times to repeat.

In the body of the `repeat` block, the program first asks granite to generate a question and add it to the document. Next we print `Answer: Let's think step by step.\n`. The following block is a repeat-until: the document in `repeat` is repeated until the condition in the `until` field becomes true. Here the condition states that we stop the iteration when variable `REASON_OR_CALC` contains `<<`. That variable is defined in the first block of the repeat-until -- we prompt a granite model and stop at the character `<<`.

The next block is an if-then-else. We check if `REASON_OR_CALC` ends with `<<` and if so we prepare for the python call to perform the arithmetic calculation. First, we have the granite model generate an `EXPR` variable, which we then use inside the `code` of the following Python block. 

When we execute this program, we obtain 3 math problems like the ones in the [examples](https://github.ibm.com/ml4code/pdl/blob/main/examples/arith/). Try it! 

## For Loops

PDL also offers `for` loops over lists.
The following [example](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/hello.pdl) simply prints each value in the list followed by a newline:

```
description: for loop
document:
- for:
    i: [1, 2, 3, 4]
  repeat: 
    "{{ i }}\n"
```

The `for` loop constructs also allows iterating over 2 or more lists of the same length simultaneously:

```
description: for loop
defs:
  numbers: {
    data: [1, 2, 3, 4]
  }
  names: {
    data: ["Bob", "Carol", "David", "Ernest"]
  }

document:
- for:
    number: "{{ numbers }}"
    name: "{{ names }}"
  repeat:
    "{{ name }}'s number is {{ number }}\n"
```

This results in the following output:

```
Bob's number is 1
Carol's number is 2
David's number is 3
Ernest's number is 4
```

## Type Checking

Consider the following PDL program ([file](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/gen-data.pdl)). It first reads the data
found [here](https://github.ibm.com/ml4code/pdl/blob/main/examples/tutorial/data.pdl) to form few-shot examples. These demonstrations show how to create
some JSON data.

```
description: Creating JSON Data
defs:
  data:
    read: examples/demo/data.pdl
    parser: yaml
    spec: { questions: [str], answers: [obj] }
document:
  model: ibm/granite-20b-code-instruct-v2
  def: model_output
  spec: {name: str, age: int}
  input: 
    - for: 
        question: "{{ data.questions }}"
        answer: "{{ data.answers }}"
      repeat:
        - |
          {{ question }}
          {{ answer }}
    - > 
      Question: Create a JSON object with fields 'name' and 'age' 
      and set them appropriately. Write the age in letters.
  parser: yaml
  parameters:
    decoding_method: greedy
    stop_sequences:
    - '}'
    include_stop_sequence: true

```

Upon reading the data we use a parser to parse it into a YAML. The `spec` field indicates the expected type for the
data, which is an object with 2 fields: `questions` and `answers` that are a list of string and a list of objects, 
respectively. When the interpreter is executed, it checks this type dynamically and throws errors if necessary.

Similarly, the output of the model call is parsed as YAML, and the `spec` indicates that we expect an object with
2 fields: `name` of type string, and `age` of type integer.

When we run this program, we obtain the output:
```
{"name": "John", "age": "thirty-two"}
examples/demo/1-gen-data.pdl:7 - Type errors during spec checking
examples/demo/1-gen-data.pdl:7 - thirty-two should be of type <class 'int'>
```

Notice that since we asked the age to be produced in letters, this causes a type error indicated above.
If we modify the prompt not to contain this directive, the type error goes away.

In general, `spec` definitions can be a subset of JSON schema, or use a shorthand notation as illustrated by
the examples below:

- `bool`: boolean
- `str`: string
- `int`: integer
- `float`: float
- `{str: {pattern: '^[A-Za-z][A-Za-z0-9_]*$'}}`: a string satisfying the indicated pattern
- `{float: {minimum: 0, exclusiveMaximum: 1}}`: a float satisfying the indicated constraints
- `{list: int}`: a list of integers
- `[int]`: a list of integers
- `{list: {int: {minimum: 0}}}`: a list of integers satisfying the indicated constraints
- `[{int: {minimum: 0}}]`: same as above
- `{list: {minItems: 1, int: {}}}`, a list satisfying the indicated constraints
- `{obj: {latitude: float, longitude: float}}`: an ibject with fields `latitude` and `longitude`
- `{latitude: float, longitude: float}`: same as above
- `{obj: {question: str, answer: str, context: {optional: str}}}`: an object with an optional field
- `{question: str, answer: str, context: {optional: str}}`: same as above
- `{list: {obj: {question: str, answer: str}}}`: a list of objects
- `[{question: str, answer: str}]`: same as above
- `{enum: [red, green, blue]}`: an enumeration


##  Debugging PDL Programs

We highly recommend to use VSCode to edit PDL YAML files. This project has been configured so that every YAML file is associated with the PDL grammar JSONSchema (see [settings](https://github.ibm.com/ml4code/pdl/blob/main/.vscode/settings.json) and [schema](https://github.ibm.com/ml4code/pdl/blob/main/pdl-schema.json)). This enables the editor to display error messages when the yaml deviates from the PDL syntax and grammar. It also provides code completion. You can set up your own VSCode PDL projects similarly using this settings and schema files. The PDL interpreter also provides similar error messages.

The interpreter prints out a log by default in the file `log.txt`. This log contains the details of inputs and outputs to every block in the program. It is useful to examine this file when the program is behaving differently than expected.

To change the log filename, you can pass it to the interpreter as follows:

```
python3 -m pdl.pdl --log <my-logfile> <my-example>
```

## Prompt Library: ReAct, ReWOO, CoT, PoT

Some of the most common prompt patterns/techniques have been implemented as PDL functions. A demo of the ReAct template:

<iframe src="https://ibm.ent.box.com/embed/s/9ko71cfbybhtn08z29bbkw74unl5faki?sortColumn=date" width="800" height="550" frameborder="0" allowfullscreen webkitallowfullscreen msallowfullscreen></iframe>

### Chain of Thought (Wei et al., 2022)

The most simple pattern is CoT (Chain of Thought). An example for arithmetic reasoning:

```
document:
  - include: examples/prompt_library/CoT.pdl
  - call: fewshot_cot
    args:
      examples:
        - question: |-
            Noah charges $60 for a large painting and $30 for a small painting.
            Last month he sold eight large paintings and four small paintings.
            If he sold twice as much this month, how much is his sales for this month?
          reasoning: |-
            He sold 8 large paintings and 4 small paintings last month.
            He sold twice as many this month.
            8 large paintings x $60 = << 8*60= 480 >> 480
            4 small paintings x $30 = << 4*30= 120 >> 120
            So he sold << 480+120= 600 >> 600 paintings last month.
            Therefore he sold << 600*2= 1200 >> this month.
          answer: $1200
        - question: |-
            Noah charges $30 for a large vases and $10 for a small vases.
            Last month he sold five large vases and three small vases.
            If he sold three times as much this month, how much is his sales for this month?
          reasoning: |-
            He sold 5 large vases and 3 small vases last month.
            He sold three times as many this month.
            5 large vases x $30 = << 5*30= 150 >> 150
            3 small vases x $10 = << 3*10= 30 >> 30
            So he sold << 150+30= 180 >> 180 vases last month.
            Therefore he sold << 180*3= 540 >> this month.
          answer: $540
  - |-
      Question: Bobby gave Alice 5 apples. Alice has 6 apples. How many apples did she have before?

      Answer: Let's think step by step. 
  - model: "ibm/granite-34b-code-instruct"
    platform: bam
```

This simple template constructs fewshot examples, which should be followed by the query/question and a model call. The output up to the model call (and thus the input to the model) would look as follows:
```
Question: Noah charges $60 for a large painting and $30 for a small painting.
Last month he sold eight large paintings and four small paintings.
If he sold twice as much this month, how much is his sales for this month?

Answer: Let's think step by step. He sold 8 large paintings and 4 small paintings last month.
He sold twice as many this month.
8 large paintings x $60 = << 8*60= 480 >> 480
4 small paintings x $30 = << 4*30= 120 >> 120
So he sold << 480+120= 600 >> 600 paintings last month.
Therefore he sold << 600*2= 1200 >> this month.
The answer is $1200.

Question: Noah charges $30 for a large vases and $10 for a small vases.
Last month he sold five large vases and three small vases.
If he sold three times as much this month, how much is his sales for this month?

Answer: Let's think step by step. He sold 5 large vases and 3 small vases last month.
He sold three times as many this month.
5 large vases x $30 = << 5*30= 150 >> 150
3 small vases x $10 = << 3*10= 30 >> 30
So he sold << 150+30= 180 >> 180 vases last month.
Therefore he sold << 180*3= 540 >> this month.
The answer is $540.

Question: Bobby gave Alice 5 apples. Alice has 6 apples. How many apples did she have before?

Answer: Let's think step by step.
```

### Program of Thought (Chen, 2022)

The PoT (Program of Thought) template includes the static fewshot prompt from (Chen, 2022). Essentially, the model is prompted to generate Python code to solve its problem, which is then executed.

```
document:
  - include: examples/prompt_library/PoT.pdl
  - def: ANSWER
    call: program_of_thought
    args:
      question: Ketty saves 20000 dollars to the bank. After three years, the sum with compound interest rate is 1000 dollars more than the sum with simple interest rate. What is the interest rate of the bank?
      model: ibm/granite-34b-code-instruct
  - "\nAnswer: {{ ANSWER }}"
```

### ReAct (Yao, 2023)

The ReAct agent pattern is essentially a question, followed by a series of thoughts, actions, and observations, collectively called the trajectory. The input question is usually followed by a thought like `I need to search for x`. This is then followed by an action `Search[x]`, and the output of this tool cool is the observation. Finally, the agent ends the trajectory with the `Finish[answer]` action.

This pattern is provided by `examples/prompt_library/ReAct.pdl`. It describes the tools, renders their examples, renders any user provided trajectories (e.g., multiple tool use), and handles the core loop until `Finish` is reached.

The first building block is the `react_block` function. This function renders a trajectory, which consist of a list of single-item maps, into text. For example:

```
document:
  - include: examples/prompt_library/ReAct.pdl
  - call: react_block
    args:
      trajectory:
        - question: "What is the elevation range for the area that the eastern sector of the Colorado orogeny extends into?"
        - thought: "I need to search Colorado orogeny, find the area that the eastern sector of the Colorado ..."
        - action: "Search[Colorado orogeny]"
        - observation: "The Colorado orogeny was an episode of mountain building (an orogeny) ..."
        - thought: "High Plains rise in elevation from around 1,800 to 7,000 ft, so the answer is 1,800 to 7,000 ft."
        - action: "Finish[1,800 to 7,000 ft]"
```

Renders to:
```
Question: What is the elevation range for the area that the eastern sector of the Colorado orogeny extends into?
Tho: I need to search Colorado orogeny, find the area that the eastern sector of the Colorado ...
Act: Search[Colorado orogeny]
Obs: The Colorado orogeny was an episode of mountain building (an orogeny) ...
Tho: High Plains rise in elevation from around 1,800 to 7,000 ft, so the answer is 1,800 to 7,000 ft.
Act: Finish[1,800 to 7,000 ft]
```

To initiate a ReAct agent, the `react` function is used. For example:
```
document:
  - include: examples/prompt_library/ReAct.pdl
  - call: react
    args:
     question: "When did the Battle of White Plains take place?"
     model: meta-llama/llama-3-70b-instruct
     tools: "{{ default_tools }}"
     trajectories: []
```

The output of the `react` function is currently a JSON object with one key, `answer`, containing the final (`Finish[..]`) answer.

The `default_tools` variable is provided by the ReAct include. **Critically**, it currently only offers `Search` and `get_current_weather`. In most cases, one will want to define their own tools. Tools and their metadata must be defined, as the `react` function uses this information to describe tools to the model, and to execute model tool usage, if the action is included in the list of tool metadata. Tools are defined as follows:
```
Search:
  function:
    subject: str
  return:
    - "[Document]\n"
    - lan: python
      code: |
        import wikipedia
        try:
          result = wikipedia.summary(subject)
        except wikipedia.WikipediaException as e:
          result = str(e)
    - "[End]\n"

default_tools:
  data:
    - name: Search
      description: Search Wikipedia for a summary
      parameters:
        - name: query
          type: string
          description: The topic of interest
      examples:
        - - question: "What is the elevation range for the area that the eastern sector of the Colorado orogeny extends into?"
          - thought: "I need to search Colorado orogeny, find the area that the eastern sector of the Colorado ..."
          - action: "Search[Colorado orogeny]"
          - observation: "The Colorado orogeny was an episode of mountain building (an orogeny) ..."
          - thought: "High Plains rise in elevation from around 1,800 to 7,000 ft, so the answer is 1,800 to 7,000 ft."
          - action: "Finish[1,800 to 7,000 ft]"
```

The tool `name` is the most important, as this must exactly match a defined PDL function. In this example, `Search` is defined right above the tool (metadata) definition. Note that all PDL tool functions in this template accept one parameter only, a string, which must be split by your function, if multiple parameters are expected. Next, the tool must be described, and its parameters defined. This is used to describe expected input(s) to the model. The parameters are a _list_, and include types and a description. Finally, a list of example trajectories should be defined to show the model how to use the tool. These trajectories follow the `react_block` pattern described above.

Finally, you can also add your own trajectories, for example to demonstrate use of multiple tools in one trajectory:
```
document:
  - include: examples/prompt_library/ReAct.pdl
  - call: react
    args:
     question: "When did the Battle of White Plains take place?"
     model: meta-llama/llama-3-70b-instruct
     tools: "{{ default_tools }}"
     trajectories:
      - - question: "What is the minimum elevation for the area that the eastern sector of the Colorado orogeny extends into, in meters?"
          - thought: "I need to search Colorado orogeny, find the area that the eastern sector of the Colorado ..."
          - action: "Search[Colorado orogeny]"
          - observation: "The Colorado orogeny was an episode of mountain building (an orogeny) ..."
          - thought: "High Plains rise in elevation from around 1,800 to 7,000 ft, I need to convert this to meters."
          - action: "Calculator[1,800*0.3048]"
          - observation: "548.64"
          - thought: "The answer is 548.64 meters"
          - action: "Finish[548.64]"
```

### ReWOO (Xu, 2023)

ReWOO (Reasoning without observation) is very similar to ReAct, but is faster and uses less tokens by having the model generate a trajectory where tool use can be _composed_ by variable reference. In practice, this means the model generates a trajectory in one generation, the PDL program parses this plan and executes tools as needed, and provides all the evidence (tool output) to the model in one request. This is in contrast to ReAct, where each step results in a whole new request to the model API.

The ReWOO function shares many similarities to the ReAct function described above. An example with a trajectory showing multiple tool use (note that these tools are not all actually defined):

```
document:
  - include: examples/prompt_library/ReWOO.pdl
  - call: rewoo
    args:
      task: "When did the Battle of White Plains take place?"
      model: ibm/granite-34b-code-instruct
      tools: "{{ default_tools }}"
      trajectories:
        - - question: Thomas, Toby, and Rebecca worked a total of 157 hours in one week. Thomas worked x hours. Toby worked 10 hours less than twice what Thomas worked, and Rebecca worked 8 hours less than Toby. How many hours did Rebecca work?
          - thought: Given Thomas worked x hours, translate the problem into algebraic expressions and solve with Wolfram Alpha.
          - action: WolframAlpha[Solve x + (2x - 10) + ((2x - 10) - 8) = 157]
          - thought: Find out the number of hours Thomas worked.
          - action: "LLM[What is x, given #E1]"
          - thought: Calculate the number of hours Rebecca worked.
          - action: "Calculator[(2 * #E2 - 10) - 8]"
      show_plans: true
```


The tool definitions are the same as for ReAct, and so are the trajectories. However, one difference is `show_plans`, which renders the parsed plans (e.g., the function calls), mostly as a debugging feature.

##  Calling PDL Programmatically from Python

Consider the following PDL program, written as Python object:

```
hello = {
    "description": "Hello world!",
    "document": ["Hello, world!\n", "This is your first prompt descriptor!\n"],
}
```

The following Python code can be used to call the interpreter programmatically:

```
state = InterpreterState()
data = Program.model_validate(hello)
result, document, _, _ = process_prog(state, empty_scope, data)
```

where `result` is a JSON object, and `document` is a string, both corresponding to the result of the program.












