description: ReWOO (Reasoning without observation) pattern from Xu et al., (http://arxiv.org/abs/2305.18323)
# Compared to ReAct, reduced token consumption (and thus execution time),
# by generating full chain of tools in a single pass
# see: https://github.com/langchain-ai/langgraph/blob/main/examples/rewoo/rewoo.ipynb
defs:
  rewoo_block:
    function:
      trajectory: { list: obj }
    return:
      text:
      - defs:
          i:
            data: 1
      - for:
          trajectory: ${ trajectory }
        repeat:
          - defs:
              type:
                text: ${ trajectory.keys()|first }
              content:
                text: ${ trajectory.values()|first }
          - if: ${ type in ['task', 'question'] }
            then: |-
              Task: ${ content|trim }
          - if: ${ type == 'thought'}
            then: |-

              Plan: ${ content|trim }
          - if: ${ type == 'action'}
            then:
              - " #E${ i } = ${ content|trim }"
              - defs:
                  i:
                    data: ${ i+1 }
          - if: ${ type == 'observation'}
            then: ""
          - if: ${ type not in ['question', 'task', 'thought', 'action', 'observation'] }
            then: "${ type }: ${ content|trim }\n"
      - "\n"

  rewoo:
    function:
      task: str
      model: str
      tools: { list: obj }
      trajectories: { list: list }
      show_plans: bool
    return:
      - defs:
          TOOL_INFO:
            call: list_tools
            args:
              tools: ${ tools }
      - |
        For the following task, make plans that can solve the problem step by step. For each plan, indicate which external tool together with tool input to retrieve evidence. You can store the evidence into a variable #E that can be called by later tools. (Plan, #E1, Plan, #E2, Plan, ...)

        Tools can be one of the following:
      - for:
          i: ${ range(1, (tools|length)+1)|list }
          name: ${ TOOL_INFO.display_names }
          sig: ${ TOOL_INFO.signatures }
          desc: ${ TOOL_INFO.descriptions }
        repeat: "(${i}) ${ sig }: ${ desc }\n"
      # # - "\n"
      - for:
          tool: ${ tools }
        repeat:
          text:
          - for:
              example: ${ tool.examples }
            repeat:
              call: rewoo_block
              args:
                trajectory: ${ example }
          - "\n"
      - for:
          traj: ${ trajectories }
        repeat:
          text:
          - call: rewoo_block
            args:
              trajectory: ${ traj }
          - "\n"
      - |
        Begin!
        Describe your plans with rich details. Each Plan should be followed by only one #E.

        ${ task }
      - def: PLANS
        model: ${ model }
        parser: # plan, step_name, tool, tool_input
          regex: 'Plan:\s*(?P<plan>(?:.|\n)*?)\s*(?P<step_name>#E\d+)\s*=\s*(?P<act>\{.+\})'
          mode: findall
        parameters:
          timeout: 30
          time_limit: 30000
          decoding_method: greedy
          stop:
            - "<|endoftext|>"
            - "\n\n"
            - "Task:"
          include_stop_sequence: false
          max_tokens: 1024
          final_prompt_value: ""
          roles:
            system:
              pre_message: ""
              post_message: ""
            user:
              pre_message: ""
              post_message: ""
            assistant:
              pre_message: ""
              post_message: ""
      - if: ${ show_plans }
        then:
          - "\n\n--- Raw plans ---\n"
          - ${ PLANS }
          - "\n\n--- Extracted Blueprint ---\n"
          - for:
              plan: ${ PLANS }
            repeat:
              - "Plan: ${ plan[0] }\n"
              - "${ plan[1] } = ${ plan[2] }\n"
          - "----------------------------\n\n"
      - defs:
          output:
            data: {}
          plans:
            for:
              plan: ${ PLANS }
            repeat:
              # text:
              - defs:
                  PLAN: ${ plan[0] }
                  ID: ${ plan[1] }
                  ACTION_RAW: ${ plan[2] }
                  ACTION:
                    parser: json
                    # spec: { name: str, arguments: obj }
                    # fallback:
                    #   data:
                    #     name: "Invalid"
                    #     arguments:
                    #       expr: ""
                    lang: python
                    code: |-
                      for k,v in output.items():
                        if k in ACTION_RAW:
                          ACTION_RAW = ACTION_RAW.replace(k, v)
                      result = ACTION_RAW
                  tool_output:
                    if: ${ ACTION.name in TOOL_INFO.display_names }
                    then:
                      call: ${ TOOL_INFO.name_map[ACTION.name] }
                      args:
                        arguments: ${ ACTION.arguments }
                    else: "Invalid action. Valid actions are ${ TOOL_INFO.signatures|join(', ') }"
              - def: output
                lang: python
                contribute: []
                code: |
                  output[ID] = str(tool_output)
                  result = output
              - |
                Plan: ${ PLAN }
                Evidence: ${ tool_output }
      - if: ${ plans is not none and plans|length > 0 }
        then:
          - def: solution_input
            text: |-
              Solve the following task or problem. To solve the problem, we have made step-by-step Plan and retrieved corresponding Evidence to each Plan. Use them with caution since long evidence might contain irrelevant information.

              ${ plans|join }
              Now solve the question or task according to provided Evidence above. Respond with the answer directly with no extra words.

              ${ task }
              Response:
          - def: SOLUTION
            model: ${ model }
            parameters:
              timeout: 30
              time_limit: 30000
              decoding_method: greedy
              stop:
                - "<|endoftext|>"
              include_stop_sequence: false
              max_tokens: 1024
              final_prompt_value: ""
              roles:
                system:
                  pre_message: ""
                  post_message: ""
                user:
                  pre_message: ""
                  post_message: ""
                assistant:
                  pre_message: ""
                  post_message: ""
            input:
              text: ${ solution_input }
        else:
          - def: SOLUTION
            text: "No plans found."
      - data:
          answer: ${ SOLUTION }

  # rewoo_old:
  #   function:
  #     task: str
  #     model: str
  #     tools: { list: obj }
  #     trajectories: { list: list }
  #     show_plans: bool
  #   return:
  #     - defs:
  #         TOOL_INFO:
  #           call: list_tools
  #           args:
  #             tools: ${ tools }
  #     - |
  #       For the following task, make plans that can solve the problem step by step. For each plan, indicate
  #       which external tool together with tool input to retrieve evidence. You can store the evidence into a
  #       variable #E that can be called by later tools. (Plan, #E1, Plan, #E2, Plan, ...)

  #       Tools can be one of the following:
  #     - for:
  #         i: ${ range(1, (tools|length)+1)|list }
  #         name: ${ TOOL_INFO.display_names }
  #         sig: ${ TOOL_INFO.signatures }
  #         desc: ${ TOOL_INFO.descriptions }
  #       repeat: |
  #         (${i}) ${ sig }: ${ desc }
  #     # - "\n"
  #     - for:
  #         tool: ${ tools }
  #       repeat:
  #         - for:
  #             example: ${ tool.examples }
  #           repeat:
  #             call: rewoo_block
  #             args:
  #               trajectory: ${ example }
  #         - "\n"
  #     - for:
  #         traj: ${ trajectories }
  #       repeat:
  #         - call: rewoo_block
  #           args:
  #             trajectory: ${ traj }
  #         - "\n"
  #     # - "\n"
  #     - |
  #       Begin!
  #       Describe your plans with rich details. Each Plan should be followed by only one #E.

  #       ${ task }
  #     - def: PLANS
  #       model: ${ model }
  #       parser: # plan, step_name, tool, tool_input
  #         regex: 'Plan:\s*(?P<plan>(?:.|\n)*?)\s*(?P<step_name>#E\d+)\s*=\s*(?P<tool>\w+)\s*\[(?P<tool_input>[^\]]+)\]'
  #         mode: findall
  #       parameters:
  #         decoding_method: greedy
  #         stop:
  #           - "<|endoftext|>"
  #           - "\n\n"
  #           - "Task:"
  #         include_stop_sequence: false
  #         max_tokens: 1024
  #         final_prompt_value: ""
  #         roles:
  #           system:
  #             pre_message: ""
  #             post_message: ""
  #           user:
  #             pre_message: ""
  #             post_message: ""
  #           assistant:
  #             pre_message: ""
  #             post_message: ""
  #     - if: ${ show_plans }
  #       then:
  #         - "\n\n--- Extracted Blueprint ---\n"
  #         - for:
  #             plan: ${ PLANS }
  #           repeat:
  #             - "Plan: ${ plan[0] }\n"
  #             - "${ plan[1] } = ${ plan[2] }[${ plan[3] }]\n"
  #         - "----------------------------\n\n"
  #     - defs:
  #         output:
  #           data: {}
  #         plans:
  #           for:
  #             plan: ${ PLANS }
  #           repeat:
  #             text:
  #             - defs:
  #                 PLAN: ${ plan[0] }
  #                 ID: ${ plan[1] }
  #                 ACTION: ${ plan[2] }
  #                 SUBJECT: ${ plan[3] }
  #                 SUBJECT_REPLACED:
  #                   lang: python
  #                   code: |-
  #                     for k,v in output.items():
  #                       if k in SUBJECT:
  #                         SUBJECT = SUBJECT.replace(k, v)
  #                     result = SUBJECT
  #                 raw_tool_output:
  #                   if: ${ ACTION in TOOL_INFO.display_names }
  #                   then:
  #                     call: ${ TOOL_INFO.name_map[ACTION] }
  #                     args:
  #                       subject: ${ SUBJECT_REPLACED }
  #                   else: "Invalid action. Valid actions are ${ TOOL_INFO.signatures|join(', ') }"
  #                 tool_output: ${ raw_tool_output }
  #             - def: output
  #               lang: python
  #               contribute: []
  #               code: |
  #                 output[ID] = str(tool_output)
  #                 result = output
  #             - |
  #               Plan: ${ PLAN }
  #               Evidence: ${ tool_output }
  #     - def: solution_input
  #       text: |-
  #         Solve the following task or problem. To solve the problem, we have made step-by-step Plan and retrieved corresponding Evidence to each Plan. Use them with caution since long evidence might contain irrelevant information.

  #         ${ plans|join }
  #         Now solve the question or task according to provided Evidence above. Respond with the answer directly with no extra words.

  #         ${ task }
  #         Response:
  #     - def: SOLUTION
  #       model: ${ model }
  #       parameters:
  #         decoding_method: greedy
  #         stop:
  #           - "<|endoftext|>"
  #         include_stop_sequence: false
  #         max_tokens: 1024
  #         final_prompt_value: ""
  #         roles:
  #           system:
  #             pre_message: ""
  #             post_message: ""
  #           user:
  #             pre_message: ""
  #             post_message: ""
  #           assistant:
  #             pre_message: ""
  #             post_message: ""
  #       input:
  #         text: ${ solution_input }
  #     - data:
  #         answer: ${ SOLUTION }
