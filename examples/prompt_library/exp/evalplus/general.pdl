description: EvalPlus simple
defs:
  react_demos:
    data:
      - - task: |-
            Write a function to find the similar elements from the given two tuple lists.
            assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)
        - thought: |-
            The similar elements here are just elements that are in both lists. I should run a solution on the test case before proposing a solution.
        - action: |-
            def similar_elements(test_tup1, test_tup2):
                res = tuple(set(test_tup1) | set(test_tup2))
                return res
            res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
            assert res == (4, 5), "Expected (4, 5) but got {}".format(res)
        - observation: |-
            ---------------------------------------------------------------------------
            AssertionError                            Traceback (most recent call last)
            Cell In[4], line 5
                  3     return res
                  4 res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
            ----> 5 assert res == (4, 5), "Expected (4, 5) but got {}".format(res)

            AssertionError: Expected (4, 5) but got (3, 4, 5, 6, 7, 10)
        - thought: |-
            To find the similar elements, I should find the intersection of the two sets. I should use the & operator instead of the | operator.
        - action: |-
            def similar_elements(test_tup1, test_tup2):
              res = tuple(set(test_tup1) & set(test_tup2))
              return res
            res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
            assert res == (4, 5), "Expected (4, 5) but got {}".format(res)
        - observation: "[Executed Successfully with No Output]"
        - thought: There is no more AssertionError. I can now submit the solution.
        - solution: |-
            def similar_elements(test_tup1, test_tup2):
              res = tuple(set(test_tup1) & set(test_tup2))
              return res
text:
  # CoT
  - if: ${ prompt_pattern == 'cot' }
    then:
      text:
      - for:
          example: ${ demonstrations }
        repeat:
          text: |+
            Task: ${ example.question }
            Solution:
            ${ example.answer }

      - |
        Task: ${ prompt }
        Solution:
      - model: ${ model }
        parameters:
          stop:
            - "<|endoftext|>"
          max_tokens: 512
          include_stop_sequence: false
          temperature: 0

  # ReAct
  - if: ${ prompt_pattern == 'react' }
    then:
      text:
      # see https://github.com/xingyaoww/mint-bench/blob/main/mint/tasks/in_context_examples/mbpp/with_tool.txt for prompt
      - include: ../../ReAct.pdl
      - for:
          traj: ${ demonstrations }
        repeat:
          text:
          - call: ${ react_code_block }
            args:
              trajectory: ${ traj }
          - "\n"
      # - "\n"
      - for:
          traj: ${ react_demos }
        repeat:
          text:
          - call: ${ react_code_block }
            args:
              trajectory: ${ traj }
          # - "\n"
      - |
        Task:
        ${ prompt|trim }

        Assistant:
        <thought>
      - defs:
          temperature: 0.7
          # decoding_method: "sample"
          SOLUTION: ""
          iterations: 0
          max_iterations: 5
      - until: ${ SOLUTION != '' or iterations>max_iterations }
        repeat:
          text:
          - until: ${ THOUGHT.endswith('</execute>') or THOUGHT.endswith('</solution>') or iterations>max_iterations }
            repeat:
              text:
              - defs:
                  iterations: ${ iterations+1 }
              - def: THOUGHT
                model: ${ model }
                parameters:
                  # truncate_input_tokens: 8191
                  # repetition_penalty: 1.05
                  # decoding_method: ${ decoding_method }
                  temperature: ${ temperature }
                  stop: ["</execute>", "</solution>", "<|endoftext|>"]
                  include_stop_sequence: true
                  max_tokens: 1024
  #             # - def: THOUGHT
  #             #   text: ${ THOUGHT|default("") }
              - if: ${ THOUGHT is none }
                then:
                  def: THOUGHT
                  text: ""

          - if: ${ THOUGHT.endswith('</execute>') }
            then:
              text:
              - "\n\nObservation ${ iterations}:\n"
              - lang: ipython
                contribute: []
                def: observation
                code: |
                  ${ THOUGHT.split('<execute>')[-1].strip('</execute>') or THOUGHT }
              - ${ (observation|trim|trim('\n')) if observation is not none else '[Executed Successfully with No Output]' }
              - "\n\nAssistant ${ iterations}:\n<thought>"
          - if: ${ THOUGHT.endswith('</solution>') }
            then:
              defs:
                SOLUTION: ${ THOUGHT.split('<solution>')[-1].strip('</solution>') or THOUGHT }
      - if: ${ iterations>max_iterations }
        then: "[ Failed to find a solution within ${ max_iterations } iterations. ]</thought>"
      - "\nSolution:\n${ SOLUTION|trim }"


      # - call: react_code_block
      #   args:
      #     trajectory: ${ demonstrations[0] }
  # - if: ${ false }
  #   then:
  #     - |
  #       Task:
  #       Write a function to find the similar elements from the given two tuple lists.
  #       assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)

  #       Assistant:
  #       <thought> The similar elements here are just elements that are in both lists. I should run a solution on the test case before proposing a solution. </thought>
  #       <execute>
  #       def similar_elements(test_tup1, test_tup2):
  #           res = tuple(set(test_tup1) | set(test_tup2))
  #           return res
  #       res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
  #       assert res == (4, 5), "Expected (4, 5) but got {}".format(res)
  #       </execute>

  #       Observation:
  #       ---------------------------------------------------------------------------
  #       AssertionError                            Traceback (most recent call last)
  #       Cell In[4], line 5
  #             3     return res
  #             4 res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
  #       ----> 5 assert res == (4, 5), "Expected (4, 5) but got {}".format(res)

  #       AssertionError: Expected (4, 5) but got (3, 4, 5, 6, 7, 10)

  #       Assistant:
  #       <thought> To find the similar elements, I should find the intersection of the two sets. I should use the & operator instead of the | operator. </thought>
  #       <execute>
  #       def similar_elements(test_tup1, test_tup2):
  #           res = tuple(set(test_tup1) & set(test_tup2))
  #           return res
  #       res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
  #       assert res == (4, 5), "Expected (4, 5) but got {}".format(res)
  #       </execute>

  #       Observation:
  #       [Executed Successfully with No Output]

  #       Assistant:
  #       <thought> There is no more AssertionError. I can now submit the solution. </thought>
  #       <solution>
  #       def similar_elements(test_tup1, test_tup2):
  #           res = tuple(set(test_tup1) & set(test_tup2))
  #           return res
  #       </solution>
  #     - "\n"
  #     - |
  #       Task:
  #       ${ prompt|trim }

  #       Assistant:
  #       <thought>
  #     - defs:
  #         temperature: 0.7
  #         decoding_method: "sample"
  #         SOLUTION: ""
  #         iterations: 0
  #         max_iterations: 5
  #     - repeat:
  #         - repeat:
  #             - defs:
  #                 iterations: ${ iterations+1 }
  #             - def: THOUGHT
  #               model: ${ model }
  #               parameters:
  #                 truncate_input_tokens: 8191
  #                 repetition_penalty: 1.05
  #                 decoding_method: ${ decoding_method }
  #                 temperature: ${ temperature }
  #                 stop: ["</execute>", "</solution>", "<|endoftext|>"]
  #                 include_stop_sequence: true
  #             - if: ${ THOUGHT is none }
  #               then:
  #                 - def: THOUGHT
  #                   text: ""
  #           until: ${ THOUGHT.endswith('</execute>') or THOUGHT.endswith('</solution>') or iterations>max_iterations }
  #         - if: ${ THOUGHT.endswith('</execute>') }
  #           then:
  #             - "\n\nObservation ${ iterations}:\n"
  #             - lang: ipython
  #               # contribute: []
  #               def: observation
  #               code: |
  #                 print("EXECUTING CODE!!")
  #                 ${ THOUGHT.split('<execute>')[-1].strip('</execute>') or THOUGHT }
  #                 print("EXECUTED CODE!!!")
  #             - ${ (observation|trim|trim('\n')) if observation is not none else '' }
  #             - "\n\nAssistant ${ iterations}:\n<thought>"
  #         - if: ${ THOUGHT.endswith('</solution>') }
  #           then:
  #             - defs:
  #                 SOLUTION: ${ THOUGHT.split('<solution>')[-1].strip('</solution>') or THOUGHT }

  #       until: ${ SOLUTION != '' or iterations>max_iterations }
  #     - if: ${ iterations>max_iterations }
  #       then: "[ Failed to find a solution within ${ max_iterations } iterations. ]</thought>"
  #     - "\nSolution:\n${ SOLUTION|trim }"

  # WITH FEEDBACK
  # Task:
  # Write a function to find the similar elements from the given two tuple lists.
  # assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)

  # Assistant:
  # <thought> The similar elements here are just elements that are in both lists. I should run a solution on the test case before proposing a solution. </thought>
  # <execute>
  # def similar_elements(test_tup1, test_tup2):
  #     res = tuple(set(test_tup1) | set(test_tup2))
  #     return res
  # res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
  # assert res == (4, 5), "Expected (4, 5) but got {}.format(res)
  # </execute>

  # Observation:
  # ---------------------------------------------------------------------------
  # AssertionError                            Traceback (most recent call last)
  # Cell In[4], line 5
  #       3     return res
  #       4 res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
  # ----> 5 assert res == (4, 5), "Expected (4, 5) but got {}.format(res)

  # AssertionError: Expected (4, 5) but got (3, 4, 5, 6, 7, 10)

  # Expert feedback:
  # This is BAD. You should not use the | operator which is the union operator.

  # Assistant:
  # <thought> To find the similar elements, I should find the intersection of the two sets. I should use the & operator instead of the | operator. </thought>
  # <execute>
  # def similar_elements(test_tup1, test_tup2):
  #     res = tuple(set(test_tup1) & set(test_tup2))
  #     return res
  # res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
  # assert res == (4, 5), "Expected (4, 5) but got {}.format(res)
  # </execute>

  # Observation:
  # [Executed Successfully with No Output]

  # Expert feedback:
  # This is GOOD. You are doing great! You can try to submit the solution now.

  # Assistant:
  # <thought> There is no more AssertionError. I can now submit the solution. </thought>
  # <solution>
  # def similar_elements(test_tup1, test_tup2):
  #     res = tuple(set(test_tup1) & set(test_tup2))
  #     return res
  # </solution>
