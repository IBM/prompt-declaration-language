description: EvalPlus simple
defs:
  react_demos:
    data:
    - - task: |-
          Write a function to find the similar elements from the given two tuple lists.
          assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)
      - thought: The similar elements here are just elements that are in both lists. I should run a solution on the test case before proposing a solution.
      - action: |-
          def similar_elements(test_tup1, test_tup2):
              res = tuple(set(test_tup1) | set(test_tup2))
              return res
          res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
          assert res == (4, 5), "Expected (4, 5) but got {}".format(res)
      - observation: |-
          ---------------------------------------------------------------------------
          AssertionError                            Traceback (most recent call last)
          Cell In[4], line 5
                3     return res
                4 res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
          ----> 5 assert res == (4, 5), "Expected (4, 5) but got {}".format(res)

          AssertionError: Expected (4, 5) but got (3, 4, 5, 6, 7, 10)
      - thought: To find the similar elements, I should find the intersection of the two sets. I should use the & operator instead of the | operator.
      - action: |-
          def similar_elements(test_tup1, test_tup2):
            res = tuple(set(test_tup1) & set(test_tup2))
            return res
          res = similar_elements((3, 4, 5, 6), (5, 7, 4, 10))
          assert res == (4, 5), "Expected (4, 5) but got {}".format(res)
      - observation: '[Executed Successfully with No Output]'
      - thought: There is no more AssertionError. I can now submit the solution.
      - solution: |-
          def similar_elements(test_tup1, test_tup2):
            res = tuple(set(test_tup1) & set(test_tup2))
            return res
  model: watsonx_text/ibm/granite-13b-instruct-v2
  prompt_pattern: react
  demonstrations:
    data:
    - - task: |-
          Write a python function to find even numbers from a mixed list.
          assert Split([1,2,3,4,5]) == [2,4]
      - thought: I should run a solution on the test case before proposing a solution.
      - action: "def Split(list): \n    ev_li = [] \n    for i in list: \n        if (i % 2 == 0): \n            ev_li.append(i)  \n    return ev_li\nres = Split([1,2,3,4,5])\nassert res == [2,4], \"Expected [2,4] but got {}\".format(res)"
      - observation: '[Executed Successfully with No Output]'
      - thought: There is no AssertionError. I can now submit the solution.
      - solution: "def Split(list): \n    ev_li = [] \n    for i in list: \n        if (i % 2 == 0): \n            ev_li.append(i)  \n    return ev_li"
    - - task: |-
          Write a function to count the frequency of consecutive duplicate elements in a given list of numbers.
          assert count_duplic([1,2,2,2,4,4,4,5,5,5,5])==([1, 2, 4, 5], [1, 3, 3, 4])
      - thought: I should run a solution on the test case before proposing a solution.
      - action: |-
          def count_duplic(lists):
              element = []
              frequency = []
              if not lists:
                  return element
              running_count = 1
              for i in range(len(lists)-1):
                  if lists[i] == lists[i+1]:
                      running_count += 1
                  else:
                      frequency.append(running_count)
                      element.append(lists[i])
                      running_count = 1
              frequency.append(running_count)
              element.append(lists[i+1])
              return element,frequency
          res = count_duplic([1,2,2,2,4,4,4,5,5,5,5])
          assert res == ([1, 2, 4, 5], [1, 3, 3, 4]), "Expected ([1, 2, 4, 5], [1, 3, 3, 4]) but got {}".format(res)
      - observation: '[Executed Successfully with No Output]'
      - thought: There is no AssertionError. I can now submit the solution.
      - solution: |-
          def count_duplic(lists):
              element = []
              frequency = []
              if not lists:
                  return element
              running_count = 1
              for i in range(len(lists)-1):
                  if lists[i] == lists[i+1]:
                      running_count += 1
                  else:
                      frequency.append(running_count)
                      element.append(lists[i])
                      running_count = 1
              frequency.append(running_count)
              element.append(lists[i+1])
              return element,frequency
    - - task: |-
          Write a function to increment the numeric values in the given strings by k.
          assert increment_numerics(["MSM", "234", "is", "98", "123", "best", "4"] , 6) == ['MSM', '240', 'is', '104', '129', 'best', '10']
      - thought: I should run a solution on the test case before proposing a solution.
      - action: |-
          def increment_numerics(test_list, K):
            res = [str(int(ele) + K) if ele.isdigit() else ele for ele in test_list]
            return res
          res = increment_numerics(["MSM", "234", "is", "98", "123", "best", "4"] , 6)
          assert res == ['MSM', '240', 'is', '104', '129', 'best', '10'], "Expected ['MSM', '240', 'is', '104', '129', 'best', '10'] but got {}".format(res)
      - observation: '[Executed Successfully with No Output]'
      - thought: There is no AssertionError. I can now submit the solution.
      - solution: |-
          def increment_numerics(test_list, K):
            res = [str(int(ele) + K) if ele.isdigit() else ele for ele in test_list]
            return res
text:
- if: ${ prompt_pattern == 'cot' }
  then:
    text:
    - for:
        example: ${ demonstrations }
      repeat:
        text: |+
          Task: ${ example.question }
          Solution:
          ${ example.answer }

    - |
      Task: ${ prompt }
      Solution:
    - model: ${ model }
      parameters:
        temperature: 0.0
        stop:
        - <|endoftext|>
        max_tokens: 512
        include_stop_sequence: false
- if: ${ prompt_pattern == 'react' }
  then:
    text:
    - include: ../../ReAct.pdl
    - for:
        traj: ${ demonstrations }
      repeat:
        text:
        - call: ${ react_code_block }
          args:
            trajectory: ${ traj }
        - |2+

    - for:
        traj: ${ react_demos }
      repeat:
        text:
        - call: ${ react_code_block }
          args:
            trajectory: ${ traj }
    - |
      Task:
      ${ prompt|trim }

      Assistant:
      <thought>
    - defs:
        temperature: 0.7
        SOLUTION: ''
        iterations: 0
        max_iterations: 5
    - repeat:
        text:
        - repeat:
            text:
            - defs:
                iterations: ${ iterations+1 }
            - def: THOUGHT
              model: ${ model }
              parameters:
                temperature: ${ temperature }
                stop:
                - </execute>
                - </solution>
                - <|endoftext|>
                max_tokens: 1024
                include_stop_sequence: true
            - if: ${ THOUGHT is none }
              then:
                def: THOUGHT
                text: ''
          until: ${ THOUGHT.endswith('</execute>') or THOUGHT.endswith('</solution>') or iterations>max_iterations }
        - if: ${ THOUGHT.endswith('</execute>') }
          then:
            text:
            - |2


              Observation ${ iterations}:
            - def: observation
              contribute: []
              lang: ipython
              code: |
                ${ THOUGHT.split('<execute>')[-1].strip('</execute>') or THOUGHT }
            - ${ (observation|trim|trim('\n')) if observation is not none else '[Executed Successfully with No Output]' }
            - |2-


              Assistant ${ iterations}:
              <thought>
        - if: ${ THOUGHT.endswith('</solution>') }
          then:
            defs:
              SOLUTION: ${ THOUGHT.split('<solution>')[-1].strip('</solution>') or THOUGHT }
      until: ${ SOLUTION != '' or iterations>max_iterations }
    - if: ${ iterations>max_iterations }
      then: '[ Failed to find a solution within ${ max_iterations } iterations. ]</thought>'
    - |2-

      Solution:
      ${ SOLUTION|trim }
